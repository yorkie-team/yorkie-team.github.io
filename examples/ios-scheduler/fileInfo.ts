import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"Scheduler","path":"/","children":[{"isFile":false,"name":"Scheduler.xcodeproj","path":"/Scheduler.xcodeproj","children":[{"isFile":false,"name":"project.xcworkspace","path":"/Scheduler.xcodeproj/project.xcworkspace","children":[{"isFile":false,"name":"xcshareddata","path":"/Scheduler.xcodeproj/project.xcworkspace/xcshareddata","children":[{"isFile":true,"isOpen":false,"language":"markup","name":"IDEWorkspaceChecks.plist","path":"/Scheduler.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist","content":""}]},{"isFile":true,"isOpen":false,"language":"xcworkspacedata","name":"contents.xcworkspacedata","path":"/Scheduler.xcodeproj/project.xcworkspace/contents.xcworkspacedata","content":""}]},{"isFile":true,"isOpen":false,"language":"properties","name":"project.pbxproj","path":"/Scheduler.xcodeproj/project.pbxproj","content":""}]},{"isFile":false,"name":"Scheduler","path":"/Scheduler","children":[{"isFile":false,"name":"Models","path":"/Scheduler/Models","children":[{"isFile":true,"isOpen":false,"language":"swift","name":"Constant.swift","path":"/Scheduler/Models/Constant.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\nimport Yorkie\n\nenum Constant {\n    private static var currentYorkieServerIP: String {\n        if let url = Bundle.main.url(forResource: \"BuildInfo\", withExtension: \"plist\"),\n           let data = try? Data(contentsOf: url),\n           let dict = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) as? [String: Any],\n           let ip = dict[\"CurrentIPAddress\"] as? String,\n           ip != \"0.0.0.0\"\n        {\n            return \"http://\\(ip):8080\"\n        }\n        return \"http://localhost:8080\"\n    }\n\n    static var serverAddress = currentYorkieServerIP\n    static var documentKey: String = {\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = Format.dateFormat\n        dateFormatter.locale = Format.local\n        let formattedDate = dateFormatter.string(from: Date())\n        let result = \"next.js-Scheduler-\\(formattedDate)\"\n        return result\n    }()\n\n    enum Format {\n        static let dateFormat = \"dd-MM-yy\"\n        static let local = Locale(identifier: \"en_US_POSIX\")\n    }\n}\n\nenum TDError: Error {\n    case cannotInitClient(String)\n}\n\nstruct ScheduleModel: JSONObjectable {\n    let date: String\n    let text: String\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"Event.swift","path":"/Scheduler/Models/Event.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Yorkie\n\nstruct Event {\n    let id: TimeTicket\n    let text: String\n\n    var uuid: String {\n        self.id.description + self.text\n    }\n}\n"}]},{"isFile":false,"name":"Assets.xcassets","path":"/Scheduler/Assets.xcassets","children":[{"isFile":false,"name":"AppIcon.appiconset","path":"/Scheduler/Assets.xcassets/AppIcon.appiconset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/Scheduler/Assets.xcassets/AppIcon.appiconset/Contents.json","content":"{\n  \"images\" : [\n    {\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"dark\"\n        }\n      ],\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"tinted\"\n        }\n      ],\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":false,"name":"AccentColor.colorset","path":"/Scheduler/Assets.xcassets/AccentColor.colorset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/Scheduler/Assets.xcassets/AccentColor.colorset/Contents.json","content":"{\n  \"colors\" : [\n    {\n      \"idiom\" : \"universal\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/Scheduler/Assets.xcassets/Contents.json","content":"{\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"markup","name":"BuildInfo.plist","path":"/Scheduler/BuildInfo.plist","content":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CurrentIPAddress</key>\n\t<string>192.168.100.149</string>\n</dict>\n</plist>\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"CalendarViewWrapper.swift","path":"/Scheduler/CalendarViewWrapper.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\nimport UIKit\n\nstruct CalendarViewWrapper: UIViewRepresentable {\n    @Binding var selectedDate: Date?\n    @Binding var eventDates: [Date]\n    var calendarView = UICalendarView()\n\n    func makeUIView(context: Context) -> UICalendarView {\n        self.calendarView.calendar = Calendar(identifier: .gregorian)\n        self.calendarView.tintColor = .systemBlue\n        self.calendarView.delegate = context.coordinator\n        self.calendarView.selectionBehavior = UICalendarSelectionSingleDate(delegate: context.coordinator)\n\n        return self.calendarView\n    }\n\n    func updateUIView(_ uiView: UICalendarView, context: Context) {\n        var dateComponents = [DateComponents]()\n        for date in context.coordinator.eventDates + self.eventDates {\n            let dateComponent = Calendar(identifier: .gregorian)\n                .dateComponents(in: .current, from: date)\n            dateComponents.append(dateComponent)\n        }\n\n        context.coordinator.eventDates = self.eventDates\n        uiView.reloadDecorations(forDateComponents: dateComponents, animated: true)\n    }\n\n    func makeCoordinator() -> Coordinator {\n        Coordinator(self)\n    }\n\n    class Coordinator: NSObject, UICalendarSelectionSingleDateDelegate, UICalendarViewDelegate {\n        var parent: CalendarViewWrapper\n        var eventDates = [Date]()\n\n        init(_ parent: CalendarViewWrapper) {\n            self.parent = parent\n        }\n\n        func dateSelection(_ selection: UICalendarSelectionSingleDate, didSelectDate dateComponents: DateComponents?) {\n            if let date = dateComponents?.date {\n                self.parent.selectedDate = date\n            }\n        }\n\n        func calendarView(\n            _ calendarView: UICalendarView,\n            decorationFor dateComponents: DateComponents\n        ) -> UICalendarView.Decoration? {\n            let day = DateComponents(\n                calendar: dateComponents.calendar,\n                year: dateComponents.year,\n                month: dateComponents.month,\n                day: dateComponents.day\n            )\n\n            if self.eventDates.contains(where: { $0 == day.date }) {\n                let circle = UICalendarView.Decoration.image(\n                    UIImage(systemName: \"circle.fill\"),\n                    color: UIColor.red,\n                    size: .large\n                )\n\n                return circle\n            }\n            return nil\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentView.swift","path":"/Scheduler/ContentView.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\nstruct ContentView: View {\n    @State var viewModel = ViewModel()\n    @State private var selectedDate: Date?\n    @State private var newEvent = \"\"\n\n    var body: some View {\n        VStack {\n            CalendarViewWrapper(\n                selectedDate: $selectedDate,\n                eventDates: self.$viewModel.scheduledDates\n            )\n            .frame(height: 450)\n\n            Spacer()\n\n            if let selectedDate {\n                VStack {\n                    ScrollView {\n                        self.makeDateDetail(selectedDate)\n                            .padding()\n                    }\n                    .scrollIndicators(.hidden, axes: .vertical)\n\n                    Spacer()\n                    self.eventEditing\n                }\n            }\n        }\n        .padding()\n        .task {\n            await self.viewModel.initializeClient()\n        }\n    }\n\n    @ViewBuilder\n    func makeDateDetail(_ date: Date) -> some View {\n        let events = self.viewModel.schedulers[date] ?? []\n\n        VStack {\n            ForEach(events, id: \\.uuid) { event in\n                EventDetailView(event: event.text, updateEvent: { updated in\n                    guard let selectedDate else { return }\n                    updateEvent(event, at: selectedDate, withNewText: updated)\n                }) {\n                    guard let selectedDate else { return }\n                    deleteEvent(event, date: selectedDate)\n                }\n            }\n        }\n    }\n\n    var eventEditing: some View {\n        VStack {\n            if let date = selectedDate {\n                let stringDate = self.viewModel.dateFormater.string(from: date)\n                Text(\"Date: \\(stringDate)\")\n            }\n\n            TextField(\"Add Event\", text: self.$newEvent)\n\n            Button {\n                addEvent(self.newEvent, to: self.selectedDate)\n            } label: {\n                Text(\"Add Event\")\n            }\n            .disabled(self.newEvent.isEmpty)\n        }\n    }\n}\n\nextension ContentView {\n    func addEvent(_ event: String, to date: Date?) {\n        guard let date else { return }\n        self.viewModel.addEvent(event, at: date)\n        // clear event name after adding\n        self.newEvent = \"\"\n    }\n\n    func deleteEvent(_ event: Event, date: Date) {\n        self.viewModel.deleteEvent(event, date: date)\n    }\n\n    func updateEvent(\n        _ event: Event,\n        at date: Date,\n        withNewText text: String\n    ) {\n        self.viewModel.updateEvent(event, at: date, withNewText: text)\n    }\n}\n\n#Preview {\n    ContentView()\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentViewModel.swift","path":"/Scheduler/ContentViewModel.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\nimport Yorkie\n\nenum ContentState {\n    case loading\n    case error(TDError)\n    case success\n}\n\n@Observable\nclass ViewModel {\n    @ObservationIgnored private var client: Client\n    @ObservationIgnored private let document: Document\n    private(set) var state = ContentState.loading\n    var schedulers = [Date: [Event]]()\n    var dateFormater: DateFormatter = {\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = Constant.Format.dateFormat\n        dateFormatter.locale = Constant.Format.local\n        return dateFormatter\n    }()\n\n    var scheduledDates = [Date]()\n\n    init() {\n        self.client = Client(Constant.serverAddress)\n        self.document = Document(key: Constant.documentKey)\n    }\n\n    func initializeClient() async {\n        self.state = .loading\n        do {\n            try await self.client.activate()\n\n            let doc = try await client.attach(self.document)\n            self.updateScheduler(from: doc)\n            self.state = .success\n\n            await self.watch()\n        } catch {\n            self.state = .error(.cannotInitClient(\"\\(error.localizedDescription)\"))\n        }\n    }\n\n    func watch() async {\n        self.document.subscribe { [weak self] event, document in\n            guard let self else { return }\n            if case .syncStatusChanged = event.type {\n                self.updateScheduler(from: document)\n            }\n        }\n    }\n\n    func updateScheduler(from document: Document) {\n        guard let array = document.getRoot().content as? JSONArray else { return }\n        let iterator = array.makeIterator()\n        var dates = [Date: [Event]]()\n        while let object = iterator.next() as? JSONObject {\n            let date = object.get(key: \"date\") as? String\n            let text = object.get(key: \"text\") as? String\n            guard let date, let text else { fatalError() }\n            guard let d = dateFormater.date(from: date) else { return }\n\n            if dates[d] == nil {\n                dates[d] = [.init(id: object.getID(), text: text)]\n            } else {\n                dates[d]?.append(.init(id: object.getID(), text: text))\n            }\n        }\n\n        self.schedulers = dates\n        self.updateScheduledDates()\n    }\n\n    func deleteEvent(_ event: Event, date: Date) {\n        try? self.document.update { root, _ in\n            guard let lists = root.content as? JSONArray else { return }\n            lists.remove(byID: event.id)\n        }\n    }\n\n    func addEvent(\n        _ name: String,\n        at date: Date\n    ) {\n        try? self.document.update { root, _ in\n            guard let lists = root.content as? JSONArray else { return }\n            let formattedDate = self.dateFormater.string(from: date)\n            let model = ScheduleModel(date: formattedDate, text: name)\n\n            lists.append(model)\n        }\n    }\n\n    func updateScheduledDates() {\n        self.scheduledDates = [Date](self.schedulers.keys)\n    }\n\n    func updateEvent(\n        _ event: Event,\n        at date: Date,\n        withNewText text: String\n    ) {\n        try? self.document.update { root, _ in\n            guard let lists = root.content as? JSONArray else { return }\n            let iterator = lists.makeIterator()\n            let formattedDate = self.dateFormater.string(from: date)\n\n            while let next = iterator.next() as? JSONObject {\n                if next.getID() == event.id, (next.get(key: \"date\") as? String ?? \"\") == formattedDate {\n                    next.set(key: \"text\", value: text)\n                    return\n                }\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"EventDetailView.swift","path":"/Scheduler/EventDetailView.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\nstruct EventDetailView: View {\n    let event: String\n    var updateEvent: (String) -> Void\n    var deleteEvent: () -> Void\n\n    @State var isEditing = false\n    @State var textEditing = \"\"\n    @FocusState var forcusField: Bool\n\n    var body: some View {\n        HStack {\n            if self.isEditing {\n                TextField(\"\", text: self.$textEditing)\n                    .focused(self.$forcusField)\n            } else {\n                Text(self.event)\n            }\n\n            Spacer()\n            if self.isEditing {\n                HStack {\n                    Button {\n                        self.updateEvent(self.textEditing)\n                        self.toggleEditing(false)\n                    } label: {\n                        Text(\"Save\")\n                    }\n\n                    Button {\n                        self.toggleEditing(false)\n                    } label: {\n                        Text(\"Cancel\")\n                    }\n                }\n            } else {\n                HStack {\n                    Button {\n                        self.toggleEditing(true)\n                    } label: {\n                        Image(systemName: \"highlighter.badge.ellipsis\")\n                            .resizable()\n                            .scaledToFit()\n                            .frame(width: 20, height: 20, alignment: .center)\n                    }\n\n                    Button {\n                        self.deleteEvent()\n                    } label: {\n                        Image(systemName: \"trash\")\n                            .resizable()\n                            .scaledToFit()\n                            .frame(width: 20, height: 20, alignment: .center)\n                    }\n                }\n            }\n        }\n        .padding(10)\n        .background(\n            RoundedRectangle(cornerRadius: 12)\n                .stroke(Color.gray, lineWidth: 2)\n        )\n    }\n\n    func toggleEditing(_ _isEditing: Bool) {\n        withAnimation {\n            self.isEditing = _isEditing\n            self.forcusField = true\n        }\n\n        if self.isEditing {\n            self.textEditing = self.event\n        } else {\n            self.textEditing = \"\"\n        }\n    }\n}\n\n#Preview {\n    EventDetailView(event: \"Go to work or Not?\") { _ in\n\n    } deleteEvent: {}\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"SchedulerApp.swift","path":"/Scheduler/SchedulerApp.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\n@main\nstruct SchedulerApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n"}]}]}