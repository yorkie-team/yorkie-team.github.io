import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"RichTextEditor","path":"/","children":[{"isFile":false,"name":"RichTextEditor.xcodeproj","path":"/RichTextEditor.xcodeproj","children":[{"isFile":false,"name":"xcshareddata","path":"/RichTextEditor.xcodeproj/xcshareddata","children":[{"isFile":false,"name":"xcschemes","path":"/RichTextEditor.xcodeproj/xcshareddata/xcschemes","children":[{"isFile":true,"isOpen":false,"language":"xcscheme","name":"RichTextEditor.xcscheme","path":"/RichTextEditor.xcodeproj/xcshareddata/xcschemes/RichTextEditor.xcscheme","content":""}]}]},{"isFile":false,"name":"project.xcworkspace","path":"/RichTextEditor.xcodeproj/project.xcworkspace","children":[{"isFile":false,"name":"xcshareddata","path":"/RichTextEditor.xcodeproj/project.xcworkspace/xcshareddata","children":[{"isFile":true,"isOpen":false,"language":"markup","name":"IDEWorkspaceChecks.plist","path":"/RichTextEditor.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist","content":""}]},{"isFile":true,"isOpen":false,"language":"xcworkspacedata","name":"contents.xcworkspacedata","path":"/RichTextEditor.xcodeproj/project.xcworkspace/contents.xcworkspacedata","content":""}]},{"isFile":true,"isOpen":false,"language":"properties","name":"project.pbxproj","path":"/RichTextEditor.xcodeproj/project.pbxproj","content":""}]},{"isFile":false,"name":"RichTextEditor","path":"/RichTextEditor","children":[{"isFile":false,"name":"Fonts","path":"/RichTextEditor/Fonts","children":[{"isFile":false,"name":"Space_Mono","path":"/RichTextEditor/Fonts/Space_Mono","children":[{"isFile":true,"isOpen":false,"language":"ttf","name":"SpaceMono-Bold.ttf","path":"/RichTextEditor/Fonts/Space_Mono/SpaceMono-Bold.ttf","content":""},{"isFile":true,"isOpen":false,"language":"ttf","name":"SpaceMono-BoldItalic.ttf","path":"/RichTextEditor/Fonts/Space_Mono/SpaceMono-BoldItalic.ttf","content":""},{"isFile":true,"isOpen":false,"language":"ttf","name":"SpaceMono-Italic.ttf","path":"/RichTextEditor/Fonts/Space_Mono/SpaceMono-Italic.ttf","content":""},{"isFile":true,"isOpen":false,"language":"ttf","name":"SpaceMono-Regular.ttf","path":"/RichTextEditor/Fonts/Space_Mono/SpaceMono-Regular.ttf","content":""}]},{"isFile":false,"name":"PT_Serif","path":"/RichTextEditor/Fonts/PT_Serif","children":[{"isFile":true,"isOpen":false,"language":"ttf","name":"PTSerif-Bold.ttf","path":"/RichTextEditor/Fonts/PT_Serif/PTSerif-Bold.ttf","content":""},{"isFile":true,"isOpen":false,"language":"ttf","name":"PTSerif-BoldItalic.ttf","path":"/RichTextEditor/Fonts/PT_Serif/PTSerif-BoldItalic.ttf","content":""},{"isFile":true,"isOpen":false,"language":"ttf","name":"PTSerif-Italic.ttf","path":"/RichTextEditor/Fonts/PT_Serif/PTSerif-Italic.ttf","content":""},{"isFile":true,"isOpen":false,"language":"ttf","name":"PTSerif-Regular.ttf","path":"/RichTextEditor/Fonts/PT_Serif/PTSerif-Regular.ttf","content":""}]}]},{"isFile":false,"name":"Assets.xcassets","path":"/RichTextEditor/Assets.xcassets","children":[{"isFile":false,"name":"AppIcon.appiconset","path":"/RichTextEditor/Assets.xcassets/AppIcon.appiconset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/RichTextEditor/Assets.xcassets/AppIcon.appiconset/Contents.json","content":"{\n  \"images\" : [\n    {\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"dark\"\n        }\n      ],\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"tinted\"\n        }\n      ],\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":false,"name":"AccentColor.colorset","path":"/RichTextEditor/Assets.xcassets/AccentColor.colorset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/RichTextEditor/Assets.xcassets/AccentColor.colorset/Contents.json","content":"{\n  \"colors\" : [\n    {\n      \"idiom\" : \"universal\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/RichTextEditor/Assets.xcassets/Contents.json","content":"{\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"markup","name":"BuildInfo.plist","path":"/RichTextEditor/BuildInfo.plist","content":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CurrentIPAddress</key>\n\t<string>192.168.100.149</string>\n</dict>\n</plist>\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"Collection+Ex.swift","path":"/RichTextEditor/Collection+Ex.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\n\nextension Collection where Element == CustomFont {\n    var attributes: [String: Bool] {\n        self.reduce(into: [String: Bool]()) { partialResult, element in\n            partialResult[element.rawValue] = true\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"Constant.swift","path":"/RichTextEditor/Constant.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\n\nenum Constant {\n    private static var currentYorkieServerIP: String {\n        if let url = Bundle.main.url(forResource: \"BuildInfo\", withExtension: \"plist\"),\n           let data = try? Data(contentsOf: url),\n           let dict = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) as? [String: Any],\n           let ip = dict[\"CurrentIPAddress\"] as? String,\n           ip != \"0.0.0.0\"\n        {\n            return \"http://\\(ip):8080\"\n        }\n        return \"http://localhost:8080\"\n    }\n\n    static var serverAddress = currentYorkieServerIP\n    static let apiKey = \"39HrKEHnMkAdXw6ZkCJQd4\"\n    static var documentKey: String = {\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyyMMdd\"\n        let dateString = dateFormatter.string(from: Date())\n        let documentKey = \"vanilla-quill-\\(dateString)\"\n        return documentKey\n    }()\n\n    enum Format {\n        static let dateFormat = \"dd-MM-yy\"\n        static let local = Locale(identifier: \"en_US_POSIX\")\n    }\n\n    enum TextInfo {\n        static let fontSize: CGFloat = 17\n    }\n}\n\nenum CustomFont: String {\n    case bold, underline, italic, strike\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentView.swift","path":"/RichTextEditor/ContentView.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\nimport UIKit\n\nstruct ContentView: View {\n    @Environment(\\.dismiss) var dismiss\n    @StateObject var viewModel = ContentViewModel()\n    @State private var showSettings = false\n    @State private var documentKey = \"\"\n\n    var appVersion: String {\n        var version = \"\"\n        if let appVersion = Bundle.main.object(forInfoDictionaryKey: \"CFBundleShortVersionString\") as? String {\n            version.append(appVersion)\n        }\n        if let buildNumber = Bundle.main.object(forInfoDictionaryKey: \"CFBundleVersion\") as? String {\n            version.append(\" build \")\n            version.append(buildNumber)\n        }\n        return version\n    }\n\n    var body: some View {\n        VStack(spacing: 0) {\n            // Header with peers and version\n            HStack(alignment: .top) {\n                Text(\"Participants: [\\(self.viewModel.localUsername), \\(self.viewModel.peers.filter { $0.name != self.viewModel.localUsername }.map { $0.name }.joined(separator: \", \"))]\")\n                    .font(.system(size: 12))\n                    .foregroundColor(.secondary)\n                    .multilineTextAlignment(.leading)\n                    .frame(maxWidth: .infinity, alignment: .leading)\n\n                Text(\"v\\(self.appVersion)\")\n                    .font(.system(size: 11))\n                // .foregroundColor(.tertiary)\n            }\n            .padding(.horizontal, 16)\n            .padding(.top, 8)\n\n            // Toolbar\n            HStack(spacing: 12) {\n                // Bold button\n                Button(action: {\n                    if let selection = self.viewModel.selection, selection.length > 0 {\n                        self.viewModel.custom(range: selection, font: .bold, value: !self.viewModel.isBold)\n                    } else {\n                        self.viewModel.toggleFormat(.bold)\n                    }\n                }) {\n                    Text(\"B\")\n                        .font(.system(size: 18, weight: .bold))\n                        .frame(maxWidth: .infinity)\n                        .frame(height: 44)\n                        .background(self.viewModel.isBold ? Color.blue.opacity(0.2) : Color(UIColor.systemBackground))\n                        .foregroundColor(.primary)\n                        .cornerRadius(8)\n                        .overlay(\n                            RoundedRectangle(cornerRadius: 8)\n                                .stroke(Color(UIColor.systemGray4), lineWidth: 1)\n                        )\n                }\n\n                // Italic button\n                Button(action: {\n                    if let selection = self.viewModel.selection, selection.length > 0 {\n                        self.viewModel.custom(range: selection, font: .italic, value: !self.viewModel.isItalic)\n                    } else {\n                        self.viewModel.toggleFormat(.italic)\n                    }\n                }) {\n                    Text(\"I\")\n                        .font(.system(size: 18).italic())\n                        .frame(maxWidth: .infinity)\n                        .frame(height: 44)\n                        .background(self.viewModel.isItalic ? Color.blue.opacity(0.2) : Color(UIColor.systemBackground))\n                        .foregroundColor(.primary)\n                        .cornerRadius(8)\n                        .overlay(\n                            RoundedRectangle(cornerRadius: 8)\n                                .stroke(Color(UIColor.systemGray4), lineWidth: 1)\n                        )\n                }\n\n                // Underline button\n                Button(action: {\n                    if let selection = self.viewModel.selection, selection.length > 0 {\n                        self.viewModel.custom(range: selection, font: .underline, value: !self.viewModel.isUnderline)\n                    } else {\n                        self.viewModel.toggleFormat(.underline)\n                    }\n                }) {\n                    Text(\"U\")\n                        .font(.system(size: 18))\n                        .underline()\n                        .frame(maxWidth: .infinity)\n                        .frame(height: 44)\n                        .background(self.viewModel.isUnderline ? Color.blue.opacity(0.2) : Color(UIColor.systemBackground))\n                        .foregroundColor(.primary)\n                        .cornerRadius(8)\n                        .overlay(\n                            RoundedRectangle(cornerRadius: 8)\n                                .stroke(Color(UIColor.systemGray4), lineWidth: 1)\n                        )\n                }\n\n                // Strikethrough button\n                Button(action: {\n                    if let selection = self.viewModel.selection, selection.length > 0 {\n                        self.viewModel.custom(range: selection, font: .strike, value: !self.viewModel.isStrikethrough)\n                    } else {\n                        self.viewModel.toggleFormat(.strike)\n                    }\n                }) {\n                    Text(\"S\")\n                        .font(.system(size: 18))\n                        .strikethrough()\n                        .frame(maxWidth: .infinity)\n                        .frame(height: 44)\n                        .background(self.viewModel.isStrikethrough ? Color.blue.opacity(0.2) : Color(UIColor.systemBackground))\n                        .foregroundColor(.primary)\n                        .cornerRadius(8)\n                        .overlay(\n                            RoundedRectangle(cornerRadius: 8)\n                                .stroke(Color(UIColor.systemGray4), lineWidth: 1)\n                        )\n                }\n            }\n            .padding(.horizontal, 16)\n            .padding(.vertical, 8)\n            .frame(height: 60)\n            .background(Color(UIColor.systemGray6))\n\n            RTUITextField(text: self.viewModel.attributeString, textField: self.viewModel.uitextView, lastEditStyle: self.viewModel.lastEditStyle, didChangeSelection: { fromIndex, toIndex in\n                self.viewModel.selection = NSRange(location: fromIndex, length: toIndex - fromIndex)\n            }, didChangeText: { range, value in\n                let pendingFormats = self.viewModel.getPendingFormats()\n                self.viewModel.updateText(ranges: range, value: value, fonts: pendingFormats)\n            })\n            .padding(16)\n        }\n        .navigationBarBackButtonHidden(true)\n        .toolbar(content: {\n            ToolbarItem(placement: .navigationBarLeading) {\n                Button(\"Back\") {\n                    self.viewModel.dismiss()\n                    self.dismiss.callAsFunction()\n                }\n            }\n        })\n        .navigationTitle(\"Rich Text Editor\")\n        .navigationBarTitleDisplayMode(.inline)\n        .task {\n            await self.viewModel.initializeClient()\n        }\n        .sheet(isPresented: self.$showSettings) {\n            NavigationView {\n                VStack(spacing: 20) {\n                    Text(\"Document Settings\")\n                        .font(.headline)\n                        .padding(.top)\n\n                    Text(\"Enter a document key to connect to a different collaborative session\")\n                        .font(.subheadline)\n                        .foregroundColor(.secondary)\n                        .multilineTextAlignment(.center)\n                        .padding(.horizontal)\n\n                    TextField(\"Document Key\", text: self.$documentKey)\n                        .textFieldStyle(.roundedBorder)\n                        .autocapitalization(.none)\n                        .autocorrectionDisabled()\n                        .padding(.horizontal)\n\n                    Spacer()\n                }\n                .navigationBarItems(\n                    leading: Button(\"Cancel\") {\n                        self.showSettings = false\n                    },\n                    trailing: Button(\"Done\") {\n                        self.showSettings = false\n                        self.viewModel.updateKeys(self.documentKey)\n                    }\n                )\n            }\n        }\n    }\n}\n\n// Wrapper for UITextView to use in SwiftUI\nstruct RichTextEditorView: UIViewRepresentable {\n    func makeUIView(context: Context) -> UITextView {\n        let textView = UITextView()\n        textView.font = UIFont.systemFont(ofSize: 18)\n        textView.backgroundColor = .systemBackground\n        textView.layer.borderColor = UIColor.systemGray4.cgColor\n        textView.layer.borderWidth = 1\n        textView.layer.cornerRadius = 8\n        textView.textContainerInset = UIEdgeInsets(top: 12, left: 8, bottom: 12, right: 8)\n        return textView\n    }\n\n    func updateUIView(_: UITextView, context: Context) {\n        // Update logic here\n    }\n}\n\n#Preview {\n    NavigationView {\n        ContentView()\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentViewModel.swift","path":"/RichTextEditor/ContentViewModel.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Combine\nimport UIKit\nimport Yorkie\n\n@MainActor\nclass ContentViewModel: ObservableObject {\n    var appVersion: String {\n        var version = \"\"\n        if let appVersion = Bundle.main.object(forInfoDictionaryKey: \"CFBundleShortVersionString\") as? String {\n            version.append(appVersion)\n        }\n\n        // Get the build number (CFBundleVersion)\n        if let buildNumber = Bundle.main.object(forInfoDictionaryKey: \"CFBundleVersion\") as? String {\n            version.append(\" build \")\n            version.append(buildNumber)\n        }\n        return version\n    }\n\n    let uitextView = UITextView()\n\n    private var client: Client\n    private var document: Document\n    var selection: NSRange? {\n        didSet {\n            self.updateMySelection()\n            Task { @MainActor in\n                self.updateFormattingStates()\n            }\n        }\n    }\n\n    private var content: String = \"\"\n    @Published var attributeString = NSMutableAttributedString(string: \"\")\n    @Published var lastEditStyle: EditStyle?\n    @Published var isBold: Bool = false\n    @Published var isItalic: Bool = false\n    @Published var isUnderline: Bool = false\n    @Published var isStrikethrough: Bool = false\n\n    var mutableAttributeString: NSMutableAttributedString {\n        self.attributeString.mutableCopy() as! NSMutableAttributedString\n    }\n\n    @MainActor\n    func updateAttribute(_ attribute: NSMutableAttributedString, _ function: String = #function) {\n        Log.log(\"[Attribute change] function: \\(function) -> \\(attribute)\", level: .debug)\n        self.attributeString = attribute\n    }\n\n    var documentKey = Constant.documentKey\n    private let apiKey = Constant.apiKey\n    @Published var peers = [Peer]()\n\n    // Generate unique username for this device\n    lazy var localUsername: String = {\n        let deviceName = UIDevice.current.name\n        let identifier = UUID().uuidString.prefix(8)\n        return \"\\(deviceName)-\\(identifier)\"\n    }()\n\n    // Generate a random color for this device\n    private lazy var localUserColor: String = {\n        let colors: [String] = [\n            \"#a83267\", \"#2196F3\", \"#4CAF50\", \"#FF9800\",\n            \"#9C27B0\", \"#00BCD4\", \"#FFEB3B\", \"#E91E63\"\n        ]\n        return colors.randomElement() ?? \"#a83267\"\n    }()\n\n    var didFinishSync = false\n    init() {\n        self.client = Client(\n            \"https://yorkie-api-qa.navercorp.com\",\n            .init(apiKey: self.apiKey)\n        )\n        // use for local server\n        // self.client = Client(Constant.serverAddress)\n\n        self.document = Document(key: self.documentKey)\n        Log.log(\"Document key: \\(self.documentKey)\", level: .info)\n        Log.log(\"API key: \\(self.apiKey)\", level: .info)\n    }\n}\n\n// MARK: - Yorkie handler\n\nextension ContentViewModel {\n    func updateKeys(_ key: String) {\n        // let key = Constant.yesterDaydocumentKey\n        guard self.documentKey != key else { return }\n        self.documentKey = key\n\n        Task {\n            try await self.client.detach(self.document)\n            self.document = Document(key: self.documentKey)\n            await self.initializeClient()\n        }\n    }\n\n    func toggleFormat(_ format: CustomFont) {\n        switch format {\n        case .bold:\n            self.isBold.toggle()\n        case .italic:\n            self.isItalic.toggle()\n        case .underline:\n            self.isUnderline.toggle()\n        case .strike:\n            self.isStrikethrough.toggle()\n        }\n        Log.log(\"toggleFormat \\(format): bold=\\(self.isBold), italic=\\(self.isItalic), underline=\\(self.isUnderline), strike=\\(self.isStrikethrough)\", level: .debug)\n    }\n\n    func dismiss() {\n        Task {\n            do {\n                try await self.client.detach(self.document)\n                try await self.client.deactivate()\n            } catch {\n                fatalError()\n            }\n        }\n    }\n\n    func getPendingFormats() -> [CustomFont] {\n        var formats: [CustomFont] = []\n        if self.isBold { formats.append(.bold) }\n        if self.isItalic { formats.append(.italic) }\n        if self.isUnderline { formats.append(.underline) }\n        if self.isStrikethrough { formats.append(.strike) }\n        return formats\n    }\n\n    func initializeClient() async {\n        Log.log(\"initializeClient\", level: .debug)\n        do {\n            try await self.client.activate()\n\n            try await self.client.attach(self.document, [\n                \"username\": self.localUsername,\n                \"color\": self.localUserColor\n            ])\n\n            try self.document.update { root, _ in\n                var text = root.content as? JSONText\n                if text == nil {\n                    root.content = JSONText()\n                    text = root.content as? JSONText\n                }\n            }\n            self.syncTextSnapShot()\n\n            await self.watch()\n        } catch {\n            Log.log(\"initializeClient Error: \\(error.localizedDescription)\", level: .error)\n        }\n    }\n\n    func updateText(ranges: [NSValue], value: String, fonts: [CustomFont]) {\n        Log.log(\"updateText: ranges: \\(ranges), value: \\(value), fonts: \\(fonts.sorted(by: { $0.rawValue > $1.rawValue }).map { $0.rawValue }.joined(separator: \", \"))\", level: .info)\n        try? self.document.update { [weak self] root, _ in\n            guard let self, let content = root.content as? JSONText else {\n                Log.log(\"content not found: \\(String(describing: root.content))\", level: .warning)\n                return\n            }\n            guard let ranges = ranges as? [NSRange], let range = ranges.first else {\n                Log.log(\"range not found: \\(ranges)\", level: .warning)\n                return\n            }\n            let toIdx = range.location + range.length\n            Log.log(\"updateText edit range: \\(range.location) -> \\(toIdx)\", level: .debug)\n            content.edit(range.location, toIdx, value, fonts.attributes)\n            if value.isEmpty {\n                // delete\n                let att = self.mutableAttributeString\n                guard att.string.count >= range.length + range.location else { return }\n                att.deleteCharacters(in: range)\n                self.updateAttribute(att)\n            } else {\n                // insert character\n                let att = self.mutableAttributeString\n\n                // Ensure insertion point is within valid bounds\n                let safeLocation = min(range.location, att.length)\n\n                let newAttribute = NSMutableAttributedString(string: value)\n                let isBold = fonts.contains(.bold)\n                let isItalic = fonts.contains(.italic)\n                var font = UIFont.defaulf\n                if isBold { font = font.boldSelf() }\n                if isItalic { font = font.italicSelf() }\n\n                // add font style (bold and italic)\n                // Use the actual length of the inserted text (handles emoji correctly)\n                let _range = NSRange(location: 0, length: (value as NSString).length)\n                newAttribute.addAttribute(.font, value: font, range: _range)\n\n                // add underline if needed\n                let isUnderline = fonts.contains(.underline)\n                if isUnderline {\n                    newAttribute.addAttributes([.underlineStyle: NSUnderlineStyle.single.rawValue], range: _range)\n                }\n                // add strike through if needed\n                let isStrike = fonts.contains(.strike)\n                if isStrike {\n                    newAttribute.addAttributes([.strikethroughStyle: NSUnderlineStyle.single.rawValue], range: _range)\n                }\n                att.insert(newAttribute, at: safeLocation)\n                self.updateAttribute(att)\n            }\n        }\n    }\n\n    func custom(range: NSRange, font: CustomFont, value: Bool) {\n        Log.log(\"custom range: [\\(range.location):\\(range.length)] -> \\(font), value: \\(value)\", level: .debug)\n        try? self.document.update { root, _ in\n            guard let content = root.content as? JSONText else { return }\n\n            let toIdx = range.location + range.length\n            Log.log(\"custom range set style: [\\(range.location):\\(toIdx)] -> \\(font), value: \\(value)\", level: .debug)\n            content.setStyle(range.location, toIdx, [font.rawValue: value])\n        }\n    }\n\n    func watch() async {\n        self.document.subscribe { [weak self] event, _ in\n            Log.log(\"did receive event \\(event.type)\", level: .debug)\n            if let event = event as? RemoteChangeEvent {\n                // adding text from FE and sync to iOS\n                // receive when peer changes text\n                let events = self?.decodeEvent(event)\n                self?.applyEvents(events)\n            } else if let event = event as? PresenceChangedEvent {\n                // receive when peer change cursor\n                self?.decodeEvent(event.value)\n            } else if let event = event as? LocalChangeEvent {\n                // apply local changes for style\n                let events = self?.decodeEvent(event)\n                self?.applyEvents(events)\n            } else if let _ = event as? SyncStatusChangedEvent {\n                self?.syncTextSnapShot()\n            } else if let event = event as? UnwatchedEvent {\n                if let name = event.value.presence[\"username\"] as? String {\n                    var peers = self?.peers ?? []\n                    let previous = peers.first(where: { $0.name == name })\n                    self?.updatePeerSelection(with: previous, peer: nil)\n\n                    if let previous, let uitextView = self?.uitextView {\n                        self?.removePeerCursor(previous, in: uitextView)\n                    }\n                    peers.removeAll(where: { $0.name == name })\n                    self?.update(peers: peers)\n                } else {\n                    Log.log(\"Can not get this peer name :\\(event.value.presence)\", level: .error)\n                }\n            } else if let event = event as? WatchedEvent {\n                self?.decodeEvent(event.value)\n            }\n        }\n    }\n}\n\nextension ContentViewModel {\n    // decode event local change with styles only\n    // adding or remove will be handled in local\n    func decodeEvent(_ event: LocalChangeEvent) -> [EditStyle] {\n        // this is local change and will apply to local only\n        // use this function to add attribute to local attribute after publishing to other peers\n        var result: [EditStyle] = []\n        let changeInfo = event.value\n        for operation in changeInfo.operations {\n            if let operation = operation as? StyleOpInfo, let attributes = operation.attributes {\n                let fromIndex = operation.from // location\n                let toIndex = operation.to // location\n                let styles = self.decodeStyle(from: attributes)\n                result.append(.style(startIndex: fromIndex, toIndex: toIndex, styles: styles))\n            }\n        }\n        Log.log(\"decode event local change: \\(result)\", level: .debug)\n        return result\n    }\n\n    func decodeEvent(_ peer: PeerElement) {\n        // change selection\n        // change cursors\n        let peerUsername = peer.presence[\"username\"] as? String ?? \"iOS\"\n        if peerUsername == self.localUsername {\n            Log.log(\"Local change, no update\", level: .debug)\n            return\n        }\n        guard let presencesChanges = peer.presence[\"selection\"] as? [Any] else {\n            Log.log(\"no selection\", level: .debug)\n            let name = peer.presence[\"username\"] as? String ?? \"anonymous\"\n            let color = peer.presence[\"color\"] as? String ?? \"anonymous\"\n            // cache previous peer selection for reuse\n            var peers = self.peers\n            let previous = peers.first(where: { $0.name == name })\n\n            peers.removeAll(where: { $0.name == name })\n            let nextPeer = Peer(clientID: peer.clientID, name: name, position: .init(), color: color)\n            peers.append(\n                nextPeer\n            )\n            self.updatePeerSelection(with: previous, peer: nextPeer)\n            self.update(peers: peers)\n\n            return\n        }\n        guard presencesChanges.count == 2 else { return }\n        let name = peer.presence[\"username\"] as? String ?? \"anonymous\"\n        let color = peer.presence[\"color\"] as? String ?? \"anonymous\"\n\n        let fromIDs: TextPosStruct? = self.decodePresence(presencesChanges.first!)\n        let toIDs: TextPosStruct? = self.decodePresence(presencesChanges.last!)\n\n        guard let fromIDs, let toIDs else {\n            Log.log(\"receive no presences changes: \\(presencesChanges)\", level: .warning)\n            return\n        }\n\n        let (fromPos, toPos) = (fromIDs, toIDs)\n\n        if let (fromIdx, toIdx) = try? (self.document.getRoot().content as? JSONText)?.posRangeToIndexRange((fromPos, toPos)) {\n            Log.log(\"found range from: [\\(fromPos):\\(toPos)] -> [\\(fromIdx):\\(toIdx)]\", level: .debug)\n            let range: NSRange\n\n            if fromIdx <= toIdx {\n                range = NSRange(location: fromIdx, length: toIdx - fromIdx)\n            } else {\n                range = NSRange(location: toIdx, length: fromIdx - toIdx)\n            }\n\n            // cache previous peer selection for reuse\n            var peers = self.peers\n            let previous = peers.first(where: { $0.name == name })\n\n            peers.removeAll(where: { $0.name == name })\n            let nextPeer = Peer(clientID: peer.clientID, name: name, position: range, color: color)\n            peers.append(\n                nextPeer\n            )\n            self.updatePeerSelection(with: previous, peer: nextPeer)\n            self.update(peers: peers)\n        } else {\n            Log.log(\"can not find range from: [\\(fromPos):\\(toPos)]\", level: .warning)\n        }\n    }\n\n    @MainActor\n    func applyEvents(_ events: [EditStyle]?) {\n        guard let events else { return }\n        Log.log(\"applyEvents: \\(events)\", level: .debug)\n        for event in events {\n            self.lastEditStyle = event\n            switch event {\n            case .add(let startIndex, let text, let styles):\n                self.add(startIndex: startIndex, text: text, styles: styles)\n            case .style(let startIndex, let toIndex, let styles):\n                self.style(startIndex: startIndex, toIndex: toIndex, styles: styles)\n            case .remove(let startIndex, let toIndex):\n                self.remove(startIndex: startIndex, toIndex: toIndex)\n            }\n        }\n    }\n\n    @MainActor\n    func add(startIndex: Int, text: String, styles: [Style]) {\n        Log.log(\"add: startIndex: \\(startIndex), text: \\(text), styles: \\(styles)\", level: .debug)\n        let newAttributeString = NSMutableAttributedString(string: text)\n        let newAppliedStyles = newAttributeString.apply(styles: styles)\n        let attributeStringss = self.mutableAttributeString\n\n        // Ensure startIndex is within valid bounds\n        let safeStartIndex = min(startIndex, attributeStringss.length)\n        attributeStringss.insert(newAppliedStyles, at: safeStartIndex)\n\n        self.updateAttribute(attributeStringss)\n    }\n\n    @MainActor\n    func style(startIndex: Int, toIndex: Int, styles: [Style]) {\n        Log.log(\"style: startIndex: \\(startIndex), toIndex: \\(toIndex), styles: \\(styles)\", level: .debug)\n        let attributeStringss = self.mutableAttributeString\n\n        // Ensure indices are within valid bounds\n        guard startIndex >= 0, toIndex <= attributeStringss.length, startIndex < toIndex else {\n            Log.log(\"style: invalid range [\\(startIndex):\\(toIndex)] for length \\(attributeStringss.length)\", level: .warning)\n            return\n        }\n\n        let newAttributeStringss = attributeStringss.apply(styles: styles, range: .init(location: startIndex, length: toIndex - startIndex))\n\n        self.updateAttribute(newAttributeStringss)\n    }\n\n    @MainActor\n    func removeStyle(startIndex: Int, toIndex: Int) {\n        Log.log(\"remove style: startIndex: \\(startIndex), toIndex: \\(toIndex)\", level: .debug)\n        let attributeStringss = self.mutableAttributeString\n\n        // Ensure indices are within valid bounds\n        guard startIndex >= 0, toIndex <= attributeStringss.length, startIndex < toIndex else {\n            Log.log(\"removeStyle: invalid range [\\(startIndex):\\(toIndex)] for length \\(attributeStringss.length)\", level: .warning)\n            return\n        }\n\n        attributeStringss.removeAttribute(.backgroundColor, range: .init(location: startIndex, length: toIndex - startIndex))\n        self.updateAttribute(attributeStringss)\n    }\n\n    @MainActor\n    func remove(startIndex: Int, toIndex: Int) {\n        Log.log(\"remove: startIndex: \\(startIndex), toIndex: \\(toIndex)\", level: .debug)\n        let attributeStringss = self.mutableAttributeString\n\n        // Ensure indices are within valid bounds\n        guard startIndex >= 0, toIndex <= attributeStringss.length, startIndex < toIndex else {\n            Log.log(\"remove: invalid range [\\(startIndex):\\(toIndex)] for length \\(attributeStringss.length)\", level: .warning)\n            return\n        }\n\n        attributeStringss.deleteCharacters(in: .init(location: startIndex, length: toIndex - startIndex))\n        self.updateAttribute(attributeStringss)\n    }\n\n    func decodeStyle(from atrributes: [String: Any]?) -> [Style] {\n        guard let atrributes else { return [] }\n        var styles = [Style]()\n        if let bold = atrributes[\"bold\"] as? String {\n            if bold == \"true\" {\n                styles.append(.bold)\n            } else if bold == \"null\" || bold == \"false\" {\n                styles.append(.unBold)\n            } else {\n                Log.log(\"can not decode style: \\(String(describing: atrributes[\"bold\"]))\", level: .error)\n            }\n        }\n        if let italic = atrributes[\"italic\"] as? String {\n            if italic == \"true\" {\n                styles.append(.italic)\n            } else if italic == \"null\" || italic == \"false\" {\n                styles.append(.unItalic)\n            } else {\n                Log.log(\"can not decode style: \\(String(describing: atrributes[\"italic\"]))\", level: .error)\n            }\n        }\n        if let underline = atrributes[\"underline\"] as? String {\n            if underline == \"true\" {\n                styles.append(.underline)\n            } else if underline == \"null\" || underline == \"false\" {\n                styles.append(.nonUnderline)\n            } else {\n                Log.log(\"can not decode style: \\(String(describing: atrributes[\"underline\"]))\", level: .error)\n            }\n        }\n        if let strike = atrributes[\"strike\"] as? String {\n            if strike == \"true\" {\n                styles.append(.strike)\n            } else if strike == \"null\" || strike == \"false\" {\n                styles.append(.unStrike)\n            } else {\n                Log.log(\"can not decode style: \\(String(describing: atrributes[\"strike\"]))\", level: .error)\n            }\n        }\n\n        Log.log(\"decoded styles: \\(styles)\", level: .debug)\n        return styles\n    }\n\n    func decodeEvent(_ event: RemoteChangeEvent) -> [EditStyle] {\n        let operations = event.value.operations\n        var result: [EditStyle] = []\n        for operation in operations {\n            if let operation = operation as? EditOpInfo {\n                let content = operation.content // this is the new string to add\n                let fromIndex = operation.from // location\n                let toIndex = operation.to\n                let styles = self.decodeStyle(from: operation.attributes)\n\n                if toIndex > fromIndex, content == nil {\n                    result.append(.remove(startIndex: fromIndex, toIndex: toIndex))\n                } else {\n                    result.append(.add(startIndex: fromIndex, text: content ?? \"\", styles: styles))\n                }\n            } else if let operation = operation as? StyleOpInfo, let attributes = operation.attributes {\n                let fromIndex = operation.from // location\n                let toIndex = operation.to\n                let styles = self.decodeStyle(from: attributes)\n                result.append(.style(startIndex: fromIndex, toIndex: toIndex, styles: styles))\n            } else {\n                Log.log(\"unhandled decoded event: \\(operation)\", level: .warning)\n            }\n        }\n        Log.log(\"decoded event: \\(result)\", level: .debug)\n        return result\n    }\n\n    func decodePresence<T: Decodable>(_ dictionary: Any?) -> T? {\n        do {\n            let dictionary = dictionary as? [String: Any]\n            guard let dictionary else {\n                return nil\n            }\n            let data = try JSONSerialization.data(withJSONObject: dictionary, options: [])\n            return try JSONDecoder().decode(T.self, from: data)\n        } catch {\n            Log.log(\"decodePresence error event: \\(error.localizedDescription)\", level: .error)\n            return nil\n        }\n    }\n}\n\nenum Style: Equatable {\n    case bold, italic, strike, underline\n    case unBold, unItalic, unStrike, nonUnderline\n    case selection(r: CGFloat, g: CGFloat, b: CGFloat)\n\n    var isBoldOrItalic: Bool {\n        [.bold, .italic, .unBold, .unItalic].contains(self)\n    }\n}\n\nenum EditStyle: Equatable {\n    case add(startIndex: Int, text: String, styles: [Style])\n    case style(startIndex: Int, toIndex: Int, styles: [Style])\n    case remove(startIndex: Int, toIndex: Int)\n}\n\nextension NSMutableAttributedString {\n    func apply(styles: [Style], range: NSRange? = nil) -> NSMutableAttributedString {\n        let attributesString = self.mutableCopy() as! Self\n        let fullRange = range ?? NSRange(location: 0, length: self.length)\n\n        if styles.isEmpty {\n            attributesString.addAttribute(.font, value: UIFont.defaulf, range: fullRange)\n            return attributesString\n        }\n\n        // handle strike and underline style\n        for style in styles where ![.bold, .unBold, .italic, .unItalic].contains(style) {\n            switch style {\n            case .strike:\n                attributesString.addAttributes([.strikethroughStyle: NSUnderlineStyle.single.rawValue], range: fullRange)\n            case .underline:\n                attributesString.addAttributes([.underlineStyle: NSUnderlineStyle.single.rawValue], range: fullRange)\n            case .unStrike:\n                attributesString.removeAttribute(.strikethroughStyle, range: fullRange)\n            case .nonUnderline:\n                attributesString.removeAttribute(.underlineStyle, range: fullRange)\n            case .selection(let r, let g, let b):\n                attributesString.addAttribute(.backgroundColor, value: UIColor(red: r, green: g, blue: b, alpha: 1), range: fullRange)\n            case .bold, .unBold, .italic, .unItalic:\n                fatalError(\"not handle here!\")\n            }\n        }\n\n        // handle font style\n        let styles = styles.filter { $0.isBoldOrItalic }\n        for style in styles {\n            attributesString.enumerateAttribute(.font, in: fullRange, options: []) { font, range, _ in\n                // use default font if there's no font exists\n                let font = font as? UIFont ?? .defaulf\n                switch style {\n                case .bold:\n                    attributesString.addAttribute(.font, value: font.boldSelf(), range: range)\n                case .italic:\n                    attributesString.addAttribute(.font, value: font.italicSelf(), range: range)\n                case .unBold:\n                    attributesString.addAttribute(.font, value: font.unBoldSelf(), range: range)\n                case .unItalic:\n                    attributesString.addAttribute(.font, value: font.unItalicSelf(), range: range)\n                default: fatalError(\"not handle here!\")\n                }\n            }\n        }\n        return attributesString\n    }\n}\n\nextension ContentViewModel {\n    func syncTextSnapShot() {\n        Log.log(\"syncTextSnapShot\", level: .debug)\n        let content = self.document.getRoot().content as? JSONText\n        guard let attributes = content?.values?.map({ $0.getAttributes() }) else { return }\n        let attributesString: NSMutableAttributedString\n        if self.content == (content?.toString ?? \"\") {\n            attributesString = self.mutableAttributeString\n        } else {\n            self.content = (content?.toString ?? \"\")\n            attributesString = NSMutableAttributedString(string: content!.toString)\n        }\n        if self.didFinishSync {\n            guard content?.toString != self.attributeString.string else {\n                print(\"nothing todo here!\")\n                return\n            }\n        }\n\n        self.didFinishSync = true\n        var step = 0\n        for (index, i) in attributes.enumerated() {\n            let text = content!.toString\n\n            let length = content!.values?[index].count ?? 0\n\n            defer { step += length }\n            guard step < text.utf16.count else { continue }\n\n            // Use UTF-16 indices to handle emoji properly\n            let utf16Start = text.utf16.index(text.utf16.startIndex, offsetBy: step)\n            let utf16End = text.utf16.index(text.utf16.startIndex, offsetBy: min(step + length, text.utf16.count))\n\n            // Convert UTF-16 indices to String indices safely\n            guard let startIndex = utf16Start.samePosition(in: text),\n                  let endIndex = utf16End.samePosition(in: text)\n            else {\n                Log.log(\"Failed to convert UTF-16 indices to String indices at step \\(step)\", level: .warning)\n                continue\n            }\n\n            let range = startIndex ..< endIndex\n\n            let nsRange = NSRange(range, in: text)\n            var font: UIFont = .defaulf\n\n            let isBold = i[\"bold\"]?.value as? String == \"true\"\n            let isItalic = i[\"italic\"]?.value as? String == \"true\"\n\n            if isBold {\n                font = font.boldSelf()\n            }\n            if isItalic {\n                font = font.italicSelf()\n            }\n\n            attributesString.addAttributes([.font: font], range: nsRange)\n\n            // Underline\n            if let underline = i[\"underline\"]?.value as? String {\n                if underline == \"true\" {\n                    attributesString.addAttributes([.underlineStyle: NSUnderlineStyle.single.rawValue], range: nsRange)\n                } else {\n                    attributesString.removeAttribute(.underlineStyle, range: nsRange)\n                }\n            }\n            // Strike\n            if let strike = i[\"strike\"]?.value as? String {\n                if strike == \"true\" {\n                    attributesString.addAttributes([.strikethroughStyle: NSUnderlineStyle.single.rawValue], range: nsRange)\n                } else {\n                    attributesString.removeAttribute(.strikethroughStyle, range: nsRange)\n                }\n            }\n        }\n\n        self.updateAttribute(attributesString)\n        // notify the view to trigger view to update\n        let peers = self.document.getPresences(false)\n\n        for peer in peers {\n            self.decodeEvent(peer)\n        }\n    }\n}\n\n// MARK: - Cursors\n\nextension ContentViewModel {\n    @MainActor\n    func updateFormattingStates() {\n        guard let selection = self.selection else {\n            // No selection, keep current button states\n            return\n        }\n\n        if self.attributeString.length == 0 {\n            // Empty text, keep current button states\n            return\n        }\n\n        // If there's a selection (length > 0), check if entire selection has the formatting\n        // If just cursor (length == 0), check at cursor position\n        let checkRange: NSRange\n        if selection.length > 0 {\n            checkRange = selection\n        } else {\n            // Check at cursor position\n            var position = selection.location\n            if position >= self.attributeString.length {\n                position = max(0, self.attributeString.length - 1)\n            }\n            checkRange = NSRange(location: position, length: 1)\n        }\n\n        // Check if entire range has each formatting\n        // Only update button states from text when there's a selection\n        // When no selection (cursor), keep the manually toggled states\n        if selection.length > 0 {\n            self.isBold = self.hasFormattingInRange(checkRange, checkBold: true)\n            self.isItalic = self.hasFormattingInRange(checkRange, checkItalic: true)\n            self.isUnderline = self.hasFormattingInRange(checkRange, checkUnderline: true)\n            self.isStrikethrough = self.hasFormattingInRange(checkRange, checkStrikethrough: true)\n        }\n    }\n\n    private func hasFormattingInRange(_ range: NSRange, checkBold: Bool = false, checkItalic: Bool = false, checkUnderline: Bool = false, checkStrikethrough: Bool = false) -> Bool {\n        guard range.location + range.length <= self.attributeString.length else { return false }\n\n        var hasFormatting = true\n        self.attributeString.enumerateAttributes(in: range, options: []) { attributes, _, stop in\n            if checkBold || checkItalic {\n                if let font = attributes[.font] as? UIFont {\n                    if checkBold && !font.fontDescriptor.symbolicTraits.contains(.traitBold) {\n                        hasFormatting = false\n                        stop.pointee = true\n                    }\n                    if checkItalic && !font.fontDescriptor.symbolicTraits.contains(.traitItalic) {\n                        hasFormatting = false\n                        stop.pointee = true\n                    }\n                } else {\n                    hasFormatting = false\n                    stop.pointee = true\n                }\n            }\n\n            if checkUnderline {\n                if let underlineStyle = attributes[.underlineStyle] as? Int, underlineStyle != 0 {\n                    // Has underline\n                } else {\n                    hasFormatting = false\n                    stop.pointee = true\n                }\n            }\n\n            if checkStrikethrough {\n                if let strikethroughStyle = attributes[.strikethroughStyle] as? Int, strikethroughStyle != 0 {\n                    // Has strikethrough\n                } else {\n                    hasFormatting = false\n                    stop.pointee = true\n                }\n            }\n        }\n\n        return hasFormatting\n    }\n\n    func updateMySelection() {\n        Log.log(\"updateMySelection\", level: .debug)\n        guard let selection else { return }\n        try? self.document.update { root, presence in\n            let fromIdx = selection.location\n            let toIdx = selection.location + selection.length\n            guard ((root.content as? JSONText)?.length ?? 0) >= fromIdx else { return }\n\n            if let range = try? (root.content as? JSONText)?.indexRangeToPosRange((fromIdx, toIdx)) {\n                let array = [range.0, range.1]\n\n                presence.set([\"selection\": array])\n\n                Log.log(\"selection: \\(fromIdx) -> \\(toIdx) | range: \\(range)\", level: .debug)\n            } else {\n                Log.log(\"selection: \\(fromIdx) -> \\(toIdx) | range: NIL\", level: .warning)\n            }\n        }\n    }\n\n    @MainActor\n    func update(peers: [Peer]) {\n        Log.log(\"peers: \\(peers.map { $0.name }.sorted().joined(separator: \", \"))\", level: .debug)\n        self.peers = peers\n        for i in peers where i.name != self.localUsername {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {\n                // TODO: - Refactor this to wait until the text is updated after adding cursor without using DispatchQueueMain\n                self.placeCursor(at: i.position.location, in: self.uitextView, with: i)\n            }\n        }\n    }\n\n    func removePeerCursor(_ peer: Peer, in textView: UITextView) {\n        let subviews = textView.subviews.filter { $0.accessibilityLabel == peer.name }\n        for subview in subviews {\n            subview.removeFromSuperview()\n        }\n    }\n\n    func placeCursor(at index: Int, in textView: UITextView, with peer: Peer) {\n        let subviews = textView.subviews.filter { $0.accessibilityLabel == peer.name }\n        for subview in subviews {\n            subview.removeFromSuperview()\n        }\n\n        guard index <= textView.text.count else { return }\n\n        // get UITextPosition from character offset\n        if let position = textView.position(from: textView.beginningOfDocument, offset: index) {\n            // Get caret rectangle at that position\n            let caretRect = textView.caretRect(for: position)\n            let _color = peer.color.rgb()\n            let color = UIColor(red: _color.r, green: _color.g, blue: _color.b, alpha: _color.a)\n\n            // Create and place custom cursor\n            let cursor = CustomCursorView(\n                frame: CGRect(x: caretRect.origin.x, y: caretRect.origin.y, width: 2, height: caretRect.height),\n                color: color\n            )\n            cursor.accessibilityLabel = peer.name\n\n            // Remove old cursor if needed\n            textView.subviews.filter { $0.accessibilityLabel == peer.clientID }.forEach { $0.removeFromSuperview() }\n\n            textView.addSubview(cursor)\n\n            let contentView = UILabel()\n            contentView.text = peer.name\n            contentView.font = UIFont.systemFont(ofSize: 14)\n            contentView.textColor = .white\n\n            contentView.backgroundColor = color\n            contentView.layer.cornerRadius = 6\n            contentView.clipsToBounds = true\n            contentView.sizeToFit()\n            let padding: CGFloat = 2\n            contentView.frame = CGRect(\n                x: caretRect.origin.x,\n                y: caretRect.maxY + padding,\n                width: contentView.frame.width + 12,\n                height: contentView.frame.height + 6\n            )\n            contentView.accessibilityLabel = peer.name\n            textView.addSubview(contentView)\n        }\n    }\n\n    func updatePeerSelection(with previous: Peer?, peer: Peer?) {\n        // Log.log(\"peer selection: \\(peer.name)|\\(peer.id)|[\\(peer.position.location),\\(peer.position.length)]\", level: .debug)\n        // prevent out of bounds\n        let attribute: NSMutableAttributedString = self.mutableAttributeString\n        // guard !self.content.isEmpty else { return }\n        if let previous, previous.position.length + previous.position.location <= self.mutableAttributeString.string.count {\n            attribute.removeAttribute(.backgroundColor, range: previous.position)\n            self.removeStyle(startIndex: previous.position.location, toIndex: previous.position.length + previous.position.location)\n        }\n\n        // color the peer when length is more than 0\n        // the peer is selecting\n        guard !self.content.isEmpty else {\n            self.updateAttribute(attribute)\n            return\n        }\n        guard let peer else { return }\n        if peer.position.length > 0, peer.position.length + peer.position.location <= self.mutableAttributeString.string.count {\n            let color = peer.color.rgb()\n            self.style(\n                startIndex: peer.position.location,\n                toIndex: peer.position.length + peer.position.location,\n                styles: [.selection(r: color.r, g: color.g, b: color.b)]\n            )\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"markup","name":"Info.plist","path":"/RichTextEditor/Info.plist","content":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>UIAppFonts</key>\n\t<array>\n\t\t<string>SpaceMono-Regular.ttf</string>\n\t\t<string>PTSerif-Bold.ttf</string>\n\t\t<string>SpaceMono-Bold.ttf</string>\n\t\t<string>PTSerif-Italic.ttf</string>\n\t\t<string>SpaceMono-BoldItalic.ttf</string>\n\t\t<string>PTSerif-BoldItalic.ttf</string>\n\t\t<string>SpaceMono-Italic.ttf</string>\n\t\t<string>PTSerif-Regular.ttf</string>\n\t</array>\n</dict>\n</plist>\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"Log.swift","path":"/RichTextEditor/Log.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\nimport os\n\nenum LogLevel {\n    case debug, info, warning, notice, error, fault\n}\n\nstruct Log {\n    static let printLog = false\n    private static let `default` = Self(category: \"DEBUG\")\n    private let logger: Logger\n\n    private init(\n        subsystem: String = Bundle.main.bundleIdentifier ?? \"com.example.app.richtext\",\n        category: String\n    ) {\n        self.logger = Logger(subsystem: subsystem, category: category)\n    }\n\n    static func log(_ message: String, level: LogLevel, _ function: String = #function, _ line: Int = #line, _ file: String = #fileID) {\n        switch level {\n        case .debug:\n            Self.default.debug(message, function, line, file)\n        case .info:\n            Self.default.info(message, function, line, file)\n        case .warning:\n            Self.default.warning(message, function, line, file)\n        case .notice:\n            Self.default.notice(message, function, line, file)\n        case .error:\n            Self.default.error(message, function, line, file)\n        case .fault:\n            Self.default.fault(message, function, line, file)\n        }\n    }\n}\n\nextension Log {\n    private func messageCentralize(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) -> String {\n        \"[LOG][\\(file):\\(function):\\(line)] -> \" + message\n    }\n\n    private func debug(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        if Self.printLog {\n            self.logger.debug(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n        }\n    }\n\n    private func info(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        if Self.printLog {\n            self.logger.info(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n        }\n    }\n\n    private func notice(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        if Self.printLog {\n            self.logger.notice(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n        }\n    }\n\n    private func warning(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        if Self.printLog {\n            self.logger.warning(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n        }\n    }\n\n    private func error(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        if Self.printLog {\n            self.logger.error(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n        }\n    }\n\n    private func fault(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        if Self.printLog {\n            self.logger.fault(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"Peer.swift","path":"/RichTextEditor/Peer.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\n\nstruct Peer: Identifiable {\n    var id: String { self.name + self.color }\n    let clientID: String\n    let name: String\n    var position: NSRange\n    let color: String\n\n    mutating func updatePosition(with range: NSRange) {\n        self.position = range\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"RTUITextField.swift","path":"/RichTextEditor/RTUITextField.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\nimport UIKit\n\nstruct RTUITextField: UIViewRepresentable {\n    var lastEditStyle: EditStyle?\n    var text: NSMutableAttributedString\n    let textField: UITextView\n    var didChangeSelection: (Int, Int) -> Void\n    var didChangeText: ([NSValue], String) -> Void\n\n    init(\n        text: NSMutableAttributedString,\n        textField: UITextView,\n        lastEditStyle: EditStyle?,\n        didChangeSelection: @escaping (Int, Int) -> Void,\n        didChangeText: @escaping ([NSValue], String) -> Void\n    ) {\n        self.text = text\n        self.textField = textField\n        self.didChangeSelection = didChangeSelection\n        self.didChangeText = didChangeText\n        self.lastEditStyle = lastEditStyle\n    }\n\n    func makeUIView(context: Context) -> UITextView {\n        self.textField.textColor = .label\n        self.textField.font = UIFont.systemFont(ofSize: Constant.TextInfo.fontSize, weight: .medium)\n        self.textField.backgroundColor = UIColor.systemGray6\n        self.textField.delegate = context.coordinator\n        return self.textField\n    }\n\n    func updateUIView(_ uiView: UITextView, context: Context) {\n        defer {\n            // save style for checking latter after change style from local or remote\n            // compare this style to make sure that is not local change\n            context.coordinator.lastEditStyle = lastEditStyle\n        }\n\n        // Don't update while composing (Hangul, emoji, etc.)\n        if context.coordinator.isComposing {\n            return\n        }\n\n        UIView.setAnimationsEnabled(false)\n        if let selectedRange = context.coordinator.selectRange, !selectedRange.isEmpty {\n            uiView.attributedText = self.text\n\n            let beginning = uiView.beginningOfDocument\n            let selectionStart = selectedRange.start\n            let selectionEnd = selectedRange.end\n\n            let location = uiView.offset(from: beginning, to: selectionStart)\n            let length = uiView.offset(from: selectionStart, to: selectionEnd)\n\n            uiView.selectedRange = NSRange(location: location, length: length)\n        } else {\n            var currentRange = uiView.selectedRange\n\n            // Use NSString for proper UTF-16 character counting (handles emoji correctly)\n            let oldText = uiView.attributedText.string as NSString\n            let newText = self.text.string as NSString\n            let difference = abs(newText.length - oldText.length)\n\n            if newText.length < oldText.length {\n                // if edit locally, there is no edit style change, then move backward the cursor after deleting text\n                if self.lastEditStyle == context.coordinator.lastEditStyle {\n                    currentRange.location = max(0, currentRange.location - difference)\n                } else {\n                    // in case deleting from remote, calculate the cursor of deleting text and\n                    // then move backward if the text index is smaller than current cursor\n                    if case .remove(let startIndex, _) = self.lastEditStyle, startIndex < currentRange.location {\n                        currentRange.location = max(0, currentRange.location - difference)\n                    }\n                }\n            } else if newText.length > oldText.length {\n                // if edit locally, there is no edit style change, then move forward the cursor after adding text\n                if self.lastEditStyle == context.coordinator.lastEditStyle {\n                    currentRange.location += difference\n                } else {\n                    // in case adding from remote, calculate the cursor of adding text and\n                    // then move forward if the text index is greater than current cursor\n                    if case .add(let startIndex, _, _) = self.lastEditStyle, currentRange.location > startIndex {\n                        currentRange.location += difference\n                    }\n                }\n                // adding text after the cursor can lead to the cursor is moving forward! += (difference)\n            }\n\n            uiView.attributedText = self.text\n            // Ensure cursor position doesn't exceed text bounds\n            currentRange.location = min(currentRange.location, newText.length)\n            uiView.selectedRange = currentRange\n        }\n        UIView.setAnimationsEnabled(true)\n    }\n\n    func makeCoordinator() -> Coordinator {\n        let coordinator = Coordinator(self)\n        coordinator.lastEditStyle = self.lastEditStyle\n        return coordinator\n    }\n\n    class Coordinator: NSObject, UITextViewDelegate {\n        var parent: RTUITextField\n        var selectRange: UITextRange?\n        var lastEditStyle: EditStyle?\n        var isComposing: Bool = false // Track IME composition state\n        var textBeforeComposition: String = \"\" // Store text before composition started\n        var compositionDebounceTimer: Timer?\n\n        init(_ parent: RTUITextField) {\n            self.parent = parent\n        }\n\n        func textViewDidChangeSelection(_ textView: UITextView) {\n            if let selectedTextRange = textView.selectedTextRange {\n                let fromIndex = self.parent.textField.offset(from: textView.beginningOfDocument, to: selectedTextRange.start)\n                let toIndex = self.parent.textField.offset(from: textView.beginningOfDocument, to: selectedTextRange.end)\n                self.selectRange = selectedTextRange\n                self.parent.didChangeSelection(fromIndex, toIndex)\n            }\n        }\n\n        func textViewDidChange(_ textView: UITextView) {\n            let isCurrentlyComposing = textView.markedTextRange != nil\n\n            // Cancel any existing debounce timer\n            self.compositionDebounceTimer?.invalidate()\n\n            if isCurrentlyComposing {\n                // Composition started or in progress\n                if !self.isComposing {\n                    // Composition just started\n                    self.isComposing = true\n                    self.textBeforeComposition = textView.text\n                }\n                // Don't send updates during composition\n                return\n            }\n\n            // Composition might have ended, use debounce to ensure we capture final text\n            if self.isComposing {\n                self.compositionDebounceTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: false) { [weak self] _ in\n                    guard let self = self else { return }\n                    self.handleCompositionEnd(textView)\n                }\n                return\n            }\n\n            // Normal text change (not during composition) - including emoji input\n            // Emoji don't trigger markedTextRange, so they come through here\n            self.handleDirectTextChange(textView)\n        }\n\n        private func handleCompositionEnd(_ textView: UITextView) {\n            self.isComposing = false\n\n            let currentText = textView.text ?? \"\"\n            let previousText = self.textBeforeComposition\n\n            // Find what changed\n            let currentNS = currentText as NSString\n            let previousNS = previousText as NSString\n\n            // Find the range that changed\n            var changeStart = 0\n            let minLength = min(currentNS.length, previousNS.length)\n\n            // Find where strings start to differ\n            for i in 0 ..< minLength {\n                if currentNS.character(at: i) != previousNS.character(at: i) {\n                    changeStart = i\n                    break\n                }\n            }\n\n            // If we didn't find a difference in common part, change is at the end\n            if changeStart == 0, minLength > 0 {\n                changeStart = minLength\n            }\n\n            if currentNS.length > previousNS.length {\n                // Text was inserted\n                let insertedLength = currentNS.length - previousNS.length\n                let insertedText = currentNS.substring(with: NSRange(location: changeStart, length: insertedLength))\n                let range = NSRange(location: changeStart, length: 0)\n                self.parent.didChangeText([range as NSValue], insertedText)\n            } else if currentNS.length < previousNS.length {\n                // Text was deleted\n                let deletedLength = previousNS.length - currentNS.length\n                let range = NSRange(location: changeStart, length: deletedLength)\n                self.parent.didChangeText([range as NSValue], \"\")\n            }\n\n            self.textBeforeComposition = \"\"\n        }\n\n        private func handleDirectTextChange(_: UITextView) {\n            // This handles direct text changes including emoji\n            // The shouldChangeTextIn already notified the parent, so we don't need to do anything here\n            // This method is kept for future enhancements if needed\n        }\n\n        // iOS 18 and earlier\n        func textView(\n            _ textView: UITextView,\n            shouldChangeTextIn range: NSRange,\n            replacementText text: String\n        ) -> Bool {\n            // Allow IME composition (markedText) to proceed\n            if textView.markedTextRange != nil || self.isComposing {\n                return true\n            }\n\n            let ranges = range as NSValue\n            self.parent.didChangeText([ranges], text)\n            return false\n        }\n\n        // iOS 26.0+ and later\n        func textView(\n            _ textView: UITextView,\n            shouldChangeTextInRanges ranges: [NSValue],\n            replacementText text: String\n        ) -> Bool {\n            // Allow IME composition (markedText) to proceed\n            if textView.markedTextRange != nil || self.isComposing {\n                return true\n            }\n\n            self.parent.didChangeText(ranges, text)\n            return false\n        }\n    }\n}\n\nclass CustomCursorView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = .red\n        self.layer.cornerRadius = 1\n    }\n\n    init(frame: CGRect, color: UIColor) {\n        super.init(frame: frame)\n        self.backgroundColor = color\n    }\n\n    @available(*, unavailable)\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"RichTextEditorApp.swift","path":"/RichTextEditor/RichTextEditorApp.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\n@main\nstruct RichTextEditorApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate\n    @Environment(\\.scenePhase) var scenePhase\n    @State var key = Constant.documentKey\n\n    var body: some Scene {\n        WindowGroup {\n            NavigationView {\n                VStack {\n                    Text(\"Input document key or use the default\")\n                    TextField(text: self.$key) {\n                        Text(\"Input documentKey\")\n                    }\n\n                    NavigationLink(destination: ContentView()) {\n                        Text(\"Go\")\n                    }\n                }\n                .padding()\n            }\n            .navigationViewStyle(.stack)\n        }.onChange(of: self.scenePhase) { newPhase in\n            Log.log(\"[ChangePhase] -> \\(newPhase)\", level: .debug)\n        }\n        .onChange(of: self.key) { newValue in\n            Constant.documentKey = newValue\n        }\n    }\n}\n\nfinal class AppDelegate: NSObject, UIApplicationDelegate {\n    func application(\n        _: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil\n    ) -> Bool {\n        return true\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"String+Ex.swift","path":"/RichTextEditor/String+Ex.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\n\nextension String {\n    /// Convert String hex to RBGA Color\n    /// - Returns: return Tuple (red, green, blue, alpha)\n    func rgb() -> (r: CGFloat, g: CGFloat, b: CGFloat, a: CGFloat) {\n        var hexSanitized = self.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()\n\n        if hexSanitized.hasPrefix(\"#\") {\n            hexSanitized.removeFirst()\n        }\n\n        if hexSanitized.count != 6, hexSanitized.count != 8 {\n            return (0, 0, 0, 0)\n        }\n\n        var rgb: UInt64 = 0\n        Scanner(string: hexSanitized).scanHexInt64(&rgb)\n\n        var r: CGFloat = 0.0\n        var g: CGFloat = 0.0\n        var b: CGFloat = 0.0\n        var a: CGFloat = 1.0\n\n        if hexSanitized.count == 6 {\n            r = CGFloat((rgb & 0xFF0000) >> 16) / 255.0\n            g = CGFloat((rgb & 0x00FF00) >> 8) / 255.0\n            b = CGFloat(rgb & 0x0000FF) / 255.0\n        } else if hexSanitized.count == 8 {\n            r = CGFloat((rgb & 0xFF00_0000) >> 24) / 255.0\n            g = CGFloat((rgb & 0x00FF_0000) >> 16) / 255.0\n            b = CGFloat((rgb & 0x0000_FF00) >> 8) / 255.0\n            a = CGFloat(rgb & 0x0000_00FF) / 255.0\n        }\n\n        return (r, g, b, a)\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"UIFont+Ex.swift","path":"/RichTextEditor/UIFont+Ex.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIKit\n\nextension UIFont {\n    func addBold() -> UIFont {\n        let font: UIFont = self\n        var combinedTraits = font.fontDescriptor.symbolicTraits\n\n        let fontDescriptor = font.fontDescriptor\n        combinedTraits.insert(.traitBold)\n        guard let boldItalicDescriptor = fontDescriptor.withSymbolicTraits(combinedTraits) else {\n            fatalError()\n        }\n        let boldItalicFont = UIFont(descriptor: boldItalicDescriptor, size: font.pointSize)\n        return boldItalicFont\n    }\n\n    func removeBold() -> UIFont {\n        let font: UIFont = self\n        var combinedTraits = font.fontDescriptor.symbolicTraits\n\n        let fontDescriptor = font.fontDescriptor\n        combinedTraits.remove(.traitBold)\n        guard let boldItalicDescriptor = fontDescriptor.withSymbolicTraits(combinedTraits) else {\n            fatalError()\n        }\n        let boldItalicFont = UIFont(descriptor: boldItalicDescriptor, size: font.pointSize)\n        return boldItalicFont\n    }\n\n    func addItalic() -> UIFont {\n        let font: UIFont = self\n        var combinedTraits = font.fontDescriptor.symbolicTraits\n\n        let fontDescriptor = font.fontDescriptor\n        combinedTraits.insert(.traitItalic)\n        guard let boldItalicDescriptor = fontDescriptor.withSymbolicTraits(combinedTraits) else {\n            fatalError()\n        }\n        let boldItalicFont = UIFont(descriptor: boldItalicDescriptor, size: font.pointSize)\n        return boldItalicFont\n    }\n\n    func removeItalic() -> UIFont {\n        let font: UIFont = self\n        var combinedTraits = font.fontDescriptor.symbolicTraits\n\n        let fontDescriptor = font.fontDescriptor\n        combinedTraits.remove(.traitItalic)\n        guard let boldItalicDescriptor = fontDescriptor.withSymbolicTraits(combinedTraits) else {\n            fatalError()\n        }\n        let boldItalicFont = UIFont(descriptor: boldItalicDescriptor, size: font.pointSize)\n        return boldItalicFont\n    }\n}\n\nextension UIFont {\n    static let defaulf = UIFont(name: \"SpaceMono-Regular\", size: Constant.TextInfo.fontSize)!\n    var isBold: Bool {\n        return fontDescriptor.symbolicTraits.contains(.traitBold)\n    }\n\n    var isItalic: Bool {\n        return fontDescriptor.symbolicTraits.contains(.traitItalic)\n    }\n\n    var isNormal: Bool {\n        return !self.isBold && !self.isItalic\n    }\n\n    func boldSelf() -> UIFont {\n        self.addBold()\n    }\n\n    func unBoldSelf() -> UIFont {\n        self.removeBold()\n    }\n\n    func italicSelf() -> UIFont {\n        self.addItalic()\n    }\n\n    func unItalicSelf() -> UIFont {\n        self.removeItalic()\n    }\n}\n"}]}]}