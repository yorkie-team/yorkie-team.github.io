import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"TextEditorApp","path":"/","children":[{"isFile":false,"name":"TextEditorApp.xcodeproj","path":"/TextEditorApp.xcodeproj","children":[{"isFile":false,"name":"xcshareddata","path":"/TextEditorApp.xcodeproj/xcshareddata","children":[{"isFile":false,"name":"xcschemes","path":"/TextEditorApp.xcodeproj/xcshareddata/xcschemes","children":[{"isFile":true,"isOpen":false,"language":"xcscheme","name":"TextEditorApp.xcscheme","path":"/TextEditorApp.xcodeproj/xcshareddata/xcschemes/TextEditorApp.xcscheme","content":""}]}]},{"isFile":false,"name":"project.xcworkspace","path":"/TextEditorApp.xcodeproj/project.xcworkspace","children":[{"isFile":false,"name":"xcshareddata","path":"/TextEditorApp.xcodeproj/project.xcworkspace/xcshareddata","children":[{"isFile":true,"isOpen":false,"language":"markup","name":"IDEWorkspaceChecks.plist","path":"/TextEditorApp.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist","content":""}]},{"isFile":true,"isOpen":false,"language":"xcworkspacedata","name":"contents.xcworkspacedata","path":"/TextEditorApp.xcodeproj/project.xcworkspace/contents.xcworkspacedata","content":""}]},{"isFile":true,"isOpen":false,"language":"properties","name":"project.pbxproj","path":"/TextEditorApp.xcodeproj/project.pbxproj","content":""}]},{"isFile":false,"name":"TextEditorApp","path":"/TextEditorApp","children":[{"isFile":false,"name":"TextEditor","path":"/TextEditorApp/TextEditor","children":[{"isFile":false,"name":"View","path":"/TextEditorApp/TextEditor/View","children":[{"isFile":true,"isOpen":false,"language":"swift","name":"PeerSelectionDisplayLayoutManager.swift","path":"/TextEditorApp/TextEditor/View/PeerSelectionDisplayLayoutManager.swift","content":"/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIKit\n\nclass PeerSelectionDisplayLayoutManager: NSLayoutManager {\n    private static let AttributeKeyPrefix = \"PEER_SELECT_\"\n\n    static func createKey(_ id: String) -> NSAttributedString.Key {\n        NSAttributedString.Key(rawValue: \"\\(self.AttributeKeyPrefix)\\(id)\")\n    }\n\n    override func drawGlyphs(forGlyphRange glyphsToShow: NSRange, at origin: CGPoint) {\n        let characterRange = self.characterRange(forGlyphRange: glyphsToShow, actualGlyphRange: nil)\n\n        textStorage?.enumerateAttributes(in: characterRange) { attrs, subrange, _ in\n            let colors = Array(attrs.filter { $0.key.rawValue.starts(with: Self.AttributeKeyPrefix) }.compactMapValues { $0 as? UIColor }.values)\n\n            let tokenGlypeRange = glyphRange(forCharacterRange: subrange, actualCharacterRange: nil)\n            self.drawBackground(forGlyphRange: tokenGlypeRange, at: origin, colors: colors)\n        }\n\n        super.drawGlyphs(forGlyphRange: glyphsToShow, at: origin)\n    }\n\n    private func drawBackground(forGlyphRange tokenGlypeRange: NSRange, at origin: CGPoint, colors: [UIColor]) {\n        guard let textContainer = textContainer(forGlyphAt: tokenGlypeRange.location, effectiveRange: nil) else { return }\n\n        let withinRange = NSRange(location: NSNotFound, length: 0)\n\n        enumerateEnclosingRects(forGlyphRange: tokenGlypeRange, withinSelectedGlyphRange: withinRange, in: textContainer) { rect, _ in\n            let tokenRect = rect.offsetBy(dx: origin.x, dy: origin.y)\n\n            for color in colors {\n                color.setFill()\n                UIBezierPath(rect: tokenRect).fill()\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"TextEditorViewController.swift","path":"/TextEditorApp/TextEditor/View/TextEditorViewController.swift","content":"/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Combine\nimport UIKit\n\nclass TextEditorViewController: UIViewController {\n    private let defaultFont = UIFont.preferredFont(forTextStyle: .body)\n    private let textView: UITextView = {\n        let textStorage = NSTextStorage()\n        let textContainer = NSTextContainer(size: .zero)\n        textContainer.widthTracksTextView = true\n        let layoutManager = PeerSelectionDisplayLayoutManager()\n        layoutManager.addTextContainer(textContainer)\n        textStorage.addLayoutManager(layoutManager)\n\n        let view = UITextView(frame: .zero, textContainer: textContainer)\n\n        view.contentInsetAdjustmentBehavior = .automatic\n        view.textAlignment = .justified\n        view.backgroundColor = UIColor(red: 244 / 256, green: 240 / 256, blue: 232 / 256, alpha: 1)\n        view.textColor = .black\n\n        return view\n    }()\n\n    private var cancellables = Set<AnyCancellable>()\n    private var model: TextViewModel?\n\n    private var isTyping = false\n    private var isHangulJamoTyping = false\n    private var isCompositioning = false {\n        didSet {\n            if oldValue != self.isCompositioning {\n                Task {\n                    do {\n                        if self.isCompositioning {\n                            try await self.model?.pause()\n                        } else {\n                            try await self.model?.resume()\n                        }\n                    } catch {\n                        assertionFailure()\n                    }\n                }\n            }\n        }\n    }\n\n    private var editOperations: [TextOperation] = []\n    private var peerSelection: [String: (NSRange, UIColor)] = [:]\n\n    private var doneEditButton: UIBarButtonItem?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.title = \"Text Editor\"\n\n        view.backgroundColor = .white\n\n        self.textView.translatesAutoresizingMaskIntoConstraints = false\n\n        view.addSubview(self.textView)\n\n        self.textView.topAnchor.constraint(equalTo: view.layoutMarginsGuide.topAnchor).isActive = true\n        self.textView.leftAnchor.constraint(equalTo: view.layoutMarginsGuide.leftAnchor).isActive = true\n        self.textView.rightAnchor.constraint(equalTo: view.layoutMarginsGuide.rightAnchor).isActive = true\n        self.textView.bottomAnchor.constraint(equalTo: view.layoutMarginsGuide.bottomAnchor).isActive = true\n\n        self.textView.textStorage.delegate = self\n        self.textView.delegate = self\n        self.textView.inputDelegate = self\n\n        self.textView.typingAttributes = [.font: self.defaultFont]\n\n        let doneAction = UIAction { [weak self] _ in\n            self?.textView.resignFirstResponder()\n        }\n\n        let button = UIBarButtonItem(systemItem: .done, primaryAction: doneAction)\n        button.isEnabled = false\n        self.navigationItem.rightBarButtonItem = button\n        self.doneEditButton = button\n    }\n\n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n\n        // Receive events from TextView Model.\n        let subject = PassthroughSubject<[TextOperation], Never>()\n\n        subject.sink { [weak self] elements in\n            Task {\n                self?.updateTextStorage(elements)\n            }\n        }.store(in: &self.cancellables)\n\n        self.model = TextViewModel(subject)\n    }\n\n    override func viewDidDisappear(_ animated: Bool) {\n        super.viewDidDisappear(animated)\n\n        Task {\n            await self.model?.cleanup()\n            self.model = nil\n        }\n    }\n\n    func updateTextStorage(_ elements: [TextOperation]) {\n        print(\"#### updateTextStorage \\(elements)\")\n\n        guard elements.isEmpty == false else {\n            return\n        }\n\n        let storage = self.textView.textStorage\n        var selection = self.textView.isFirstResponder ? self.textView.selectedTextRange : nil\n\n        storage.beginEditing()\n\n        for element in elements {\n            switch element {\n            case .edit(range: let range, content: let content):\n                let range = range ?? NSRange(location: 0, length: storage.length)\n\n                storage.replaceCharacters(in: range, with: content)\n\n                if content.isEmpty == false {\n                    let attrRange = NSRange(location: range.location, length: content.count)\n\n                    storage.addAttributes([.font: self.defaultFont], range: attrRange)\n                    storage.fixAttributes(in: attrRange)\n                }\n\n                let delta = content.isEmpty ? -range.length : content.count - range.length\n\n                // Correct cursor positon.\n                if let prev = selection {\n                    let prevStartIndex = self.textView.offset(from: self.textView.beginningOfDocument, to: prev.start)\n\n                    if prevStartIndex >= range.location,\n                       let newPosStart = self.textView.position(from: prev.start, offset: delta),\n                       let newPosEnd = self.textView.position(from: prev.end, offset: delta)\n                    {\n                        selection = self.textView.textRange(from: newPosStart, to: newPosEnd)\n                    } else {\n                        selection = nil\n                    }\n                }\n\n                // Correct peer selection position.\n                for selection in self.peerSelection {\n                    var prevSelectRange = selection.value.0\n                    let newDocEnd = storage.length\n\n                    if newDocEnd < prevSelectRange.location {\n                        prevSelectRange = NSRange(location: 0, length: 0)\n                    } else {\n                        if prevSelectRange.location > range.location {\n                            prevSelectRange = NSRange(location: prevSelectRange.location + delta, length: prevSelectRange.length)\n                        }\n\n                        if prevSelectRange.location + prevSelectRange.length > range.location {\n                            prevSelectRange = NSRange(location: prevSelectRange.location, length: prevSelectRange.length + delta)\n                        }\n                    }\n\n                    self.peerSelection[selection.key] = (prevSelectRange, selection.value.1)\n                }\n\n                self.peerSelection = self.peerSelection.filter { $0.value.0.length > 0 }\n\n            case .select(let range, let actorID):\n                print(\"#### select \\(range) \\(self.textView.textStorage.length)\")\n\n                let newColor = UIColor(red: CGFloat.random(in: 0 ... 1), green: CGFloat.random(in: 0 ... 1), blue: CGFloat.random(in: 0 ... 1), alpha: 0.2)\n\n                if let color = peerSelection[actorID]?.1 {\n                    self.peerSelection[actorID] = (range, color)\n                } else {\n                    self.peerSelection[actorID] = (range, newColor)\n                }\n            }\n        }\n\n        self.redrawPeerSelections()\n\n        storage.endEditing()\n\n        // Must change selectedTextRange after endEditing()\n        if let selection {\n            self.textView.selectedTextRange = selection\n        }\n    }\n\n    func redrawPeerSelections() {\n        let storage = self.textView.textStorage\n\n        for (key, value) in self.peerSelection {\n            let key = PeerSelectionDisplayLayoutManager.createKey(key)\n            let allRange = NSRange(location: 0, length: storage.length)\n\n            // The local value may be different from the value of the peer.\n            let newRange = NSIntersectionRange(allRange, value.0)\n\n            print(\"#### newRange \\(newRange), \\(value.0), \\(storage.length)\")\n\n            storage.removeAttribute(key, range: allRange)\n            storage.addAttribute(key, value: value.1, range: newRange)\n        }\n    }\n}\n\nextension TextEditorViewController: UITextViewDelegate {\n    func textViewDidBeginEditing(_: UITextView) {\n        self.doneEditButton?.isEnabled = true\n        self.isCompositioning = false\n    }\n\n    func textViewDidEndEditing(_: UITextView) {\n        self.doneEditButton?.isEnabled = false\n        self.isCompositioning = false\n    }\n\n    func textViewDidChange(_: UITextView) {\n        let isMultiStageInput = self.textView.markedTextRange != nil\n\n        self.isCompositioning = (self.isHangulJamoTyping || isMultiStageInput)\n\n        self.isTyping = false\n\n        let operations = self.editOperations\n        self.editOperations = []\n\n        Task { [weak self] in\n            await self?.model?.edit(operations)\n        }\n    }\n\n    func textView(_: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {\n        let str = text as NSString\n\n        self.isTyping = true\n        self.isHangulJamoTyping = false\n\n        if str.length == 1 {\n            let firstCharacter = str.character(at: 0)\n\n            // Hangul Compatibility Jamo\n            if firstCharacter > 0x3130 && firstCharacter < 0x318F {\n                self.isHangulJamoTyping = true\n            }\n        }\n\n        return true\n    }\n\n    func textViewDidChangeSelection(_ textView: UITextView) {\n        if let selectedTextRange = textView.selectedTextRange {\n            let fromIndex = self.textView.offset(from: self.textView.beginningOfDocument, to: selectedTextRange.start)\n            let toIndex = self.textView.offset(from: self.textView.beginningOfDocument, to: selectedTextRange.end)\n\n            print(\"#### \\(fromIndex), \\(toIndex)\")\n\n            Task { [weak self] in\n                await self?.model?.edit([.select(range: NSRange(location: fromIndex, length: toIndex - fromIndex), actorID: \"\")])\n            }\n        }\n    }\n}\n\nextension TextEditorViewController: NSTextStorageDelegate {\n    func textStorage(_ textStorage: NSTextStorage, didProcessEditing editedMask: NSTextStorage.EditActions, range editedRange: NSRange, changeInLength delta: Int) {\n        print(\"didProcessEditiong called...\\(editedRange), \\(delta)\")\n\n        guard self.textView.isFirstResponder else {\n            return\n        }\n\n        let changedString = textStorage.mutableString.substring(with: editedRange)\n\n        if editedMask.contains(.editedCharacters) {\n            if self.isTyping {\n                let rangeParameter = NSRange(location: editedRange.location, length: delta < 0 ? -delta : changedString.count - delta)\n\n                print(\"Char changed ... \\(rangeParameter) [\\(changedString)]\")\n\n                self.editOperations.append(.edit(range: rangeParameter, content: changedString))\n\n                if changedString.isEmpty == false {\n                    let firstCharacter = (changedString as NSString).character(at: 0)\n                    // Hangul Compatibility vowels.\n                    if firstCharacter >= 0x314F && firstCharacter <= 0x3163 ||\n                        firstCharacter >= 0x3187 && firstCharacter <= 0x318E\n                    {\n                        self.isHangulJamoTyping = false\n                    }\n                }\n            }\n        }\n\n        if editedMask.contains(.editedAttributes) {\n            // TODO(humdrum): Implement attributes editing\n        }\n    }\n}\n\nextension TextEditorViewController: UITextInputDelegate {\n    func selectionWillChange(_: UITextInput?) {}\n\n    func selectionDidChange(_: UITextInput?) {\n        self.isCompositioning = false\n    }\n\n    func textWillChange(_: UITextInput?) {}\n\n    func textDidChange(_: UITextInput?) {}\n\n    @available(iOS 18.4, *)\n    func conversationContext(_: UIConversationContext?, didChange textInput: (any UITextInput)?) {}\n}\n"}]},{"isFile":true,"isOpen":false,"language":"swift","name":"TextViewModel.swift","path":"/TextEditorApp/TextEditor/TextViewModel.swift","content":"/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Combine\nimport Foundation\nimport UIKit\nimport Yorkie\n\nenum TextOperation {\n    case edit(range: NSRange?, content: String)\n    case select(range: NSRange, actorID: String)\n}\n\nclass TextViewModel {\n    private var client: Client\n    private let document: Document\n\n    private weak var operationSubject: PassthroughSubject<[TextOperation], Never>?\n\n    init(_ operationSubject: PassthroughSubject<[TextOperation], Never>) {\n        self.operationSubject = operationSubject\n\n        // create client with RPCAddress.\n        self.client = Client(\"http://localhost:8080\")\n\n        // create a document\n        self.document = Document(key: \"codemirror\")\n\n        Task {\n            // activate client.\n            try! await self.client.activate()\n\n            // attach the document into the client.\n            try! await self.client.attach(self.document)\n\n            try await self.document.update { root, _ in\n                var text = root.content as? JSONText\n                if text == nil {\n                    root.content = JSONText()\n                    text = root.content as? JSONText\n                }\n            }\n\n            // subscribe document event.\n            await self.document.subscribe { [weak self] event, _ in\n                switch event.type {\n                case .snapshot, .remoteChange:\n                    Task { [weak self] in\n                        await self?.syncText()\n                    }\n                default:\n                    break\n                }\n            }\n\n            await self.document.subscribePresence(.others) { [weak self] event, document in\n                if let event = event as? PresenceChangedEvent {\n                    if let fromPos: TextPosStruct = self?.decodePresence(event.value.presence[\"from\"]),\n                       let toPos: TextPosStruct = self?.decodePresence(event.value.presence[\"to\"])\n                    {\n                        Task { [weak self] in\n                            if let (fromIdx, toIdx) = try? (document.getRoot().content as? JSONText)?.posRangeToIndexRange((fromPos, toPos)) {\n                                let range: NSRange\n\n                                if fromIdx <= toIdx {\n                                    range = NSRange(location: fromIdx, length: toIdx - fromIdx)\n                                } else {\n                                    range = NSRange(location: toIdx, length: fromIdx - toIdx)\n                                }\n\n                                self?.operationSubject?.send([.select(range: range, actorID: event.value.clientID)])\n                            }\n                        }\n                    }\n                }\n            }\n\n            await self.syncText()\n        }\n    }\n\n    func syncText() async {\n        let context = (await self.document.getRoot().content as? JSONText)?.toString ?? \"\"\n\n        self.operationSubject?.send([.edit(range: nil, content: context)])\n    }\n\n    func cleanup() async {\n        do {\n            try await self.client.detach(self.document)\n            try await self.client.deactivate()\n        } catch {\n            // handle error\n//            print(error.localizedDescription)\n        }\n    }\n\n    func edit(_ operaitions: [TextOperation]) async {\n        try? await self.document.update { root, presence in\n            guard let content = root.content as? JSONText else {\n                return\n            }\n\n            for operation in operaitions {\n                switch operation {\n                case .edit(let range, let contentString):\n                    guard let range = range else {\n                        return\n                    }\n\n                    let toIdx = range.location + range.length\n\n                    content.edit(range.location, toIdx, contentString)\n                case .select(let range, _):\n                    let fromIdx = range.location\n                    let toIdx = range.location + range.length\n\n                    guard ((root.content as? JSONText)?.length ?? 0) >= fromIdx else {\n                        return\n                    }\n\n                    if let range = try? (root.content as? JSONText)?.indexRangeToPosRange((fromIdx, toIdx)) {\n                        presence.set([\"from\": range.0, \"to\": range.1])\n                    }\n                }\n            }\n        }\n    }\n\n    func pause() async throws {\n        try await self.client.changeSyncMode(self.document, .realtimePushOnly)\n    }\n\n    func resume() async throws {\n        try await self.client.changeSyncMode(self.document, .realtime)\n    }\n\n    private func decodePresence<T: Decodable>(_ dictionary: Any?) -> T? {\n        guard let dictionary = dictionary as? [String: Any],\n              let data = try? JSONSerialization.data(withJSONObject: dictionary, options: [])\n        else {\n            return nil\n        }\n\n        return try? JSONDecoder().decode(T.self, from: data)\n    }\n}\n"}]},{"isFile":false,"name":"Base.lproj","path":"/TextEditorApp/Base.lproj","children":[{"isFile":true,"isOpen":false,"language":"markup","name":"LaunchScreen.storyboard","path":"/TextEditorApp/Base.lproj/LaunchScreen.storyboard","content":"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<document type=\"com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB\" version=\"3.0\" toolsVersion=\"13122.16\" targetRuntime=\"iOS.CocoaTouch\" propertyAccessControl=\"none\" useAutolayout=\"YES\" launchScreen=\"YES\" useTraitCollections=\"YES\" useSafeAreas=\"YES\" colorMatched=\"YES\" initialViewController=\"01J-lp-oVM\">\n    <dependencies>\n        <plugIn identifier=\"com.apple.InterfaceBuilder.IBCocoaTouchPlugin\" version=\"13104.12\"/>\n        <capability name=\"Safe area layout guides\" minToolsVersion=\"9.0\"/>\n        <capability name=\"documents saved in the Xcode 8 format\" minToolsVersion=\"8.0\"/>\n    </dependencies>\n    <scenes>\n        <!--View Controller-->\n        <scene sceneID=\"EHf-IW-A2E\">\n            <objects>\n                <viewController id=\"01J-lp-oVM\" sceneMemberID=\"viewController\">\n                    <view key=\"view\" contentMode=\"scaleToFill\" id=\"Ze5-6b-2t3\">\n                        <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"375\" height=\"667\"/>\n                        <autoresizingMask key=\"autoresizingMask\" widthSizable=\"YES\" heightSizable=\"YES\"/>\n                        <color key=\"backgroundColor\" xcode11CocoaTouchSystemColor=\"systemBackgroundColor\" cocoaTouchSystemColor=\"whiteColor\"/>\n                        <viewLayoutGuide key=\"safeArea\" id=\"6Tk-OE-BBY\"/>\n                    </view>\n                </viewController>\n                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"iYj-Kq-Ea1\" userLabel=\"First Responder\" sceneMemberID=\"firstResponder\"/>\n            </objects>\n            <point key=\"canvasLocation\" x=\"53\" y=\"375\"/>\n        </scene>\n    </scenes>\n</document>\n"},{"isFile":true,"isOpen":false,"language":"markup","name":"Main.storyboard","path":"/TextEditorApp/Base.lproj/Main.storyboard","content":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<document type=\"com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB\" version=\"3.0\" toolsVersion=\"21507\" targetRuntime=\"iOS.CocoaTouch\" propertyAccessControl=\"none\" useAutolayout=\"YES\" useTraitCollections=\"YES\" useSafeAreas=\"YES\" colorMatched=\"YES\" initialViewController=\"dGJ-hY-XG2\">\n    <device id=\"retina6_12\" orientation=\"portrait\" appearance=\"light\"/>\n    <dependencies>\n        <deployment identifier=\"iOS\"/>\n        <plugIn identifier=\"com.apple.InterfaceBuilder.IBCocoaTouchPlugin\" version=\"21505\"/>\n        <capability name=\"Safe area layout guides\" minToolsVersion=\"9.0\"/>\n        <capability name=\"System colors in document resources\" minToolsVersion=\"11.0\"/>\n        <capability name=\"documents saved in the Xcode 8 format\" minToolsVersion=\"8.0\"/>\n    </dependencies>\n    <scenes>\n        <!--View Controller-->\n        <scene sceneID=\"tne-QT-ifu\">\n            <objects>\n                <viewController id=\"BYZ-38-t0r\" customClass=\"ViewController\" customModule=\"TextEditorApp\" customModuleProvider=\"target\" sceneMemberID=\"viewController\">\n                    <view key=\"view\" contentMode=\"scaleToFill\" id=\"8bC-Xf-vdC\">\n                        <rect key=\"frame\" x=\"0.0\" y=\"0.0\" width=\"393\" height=\"852\"/>\n                        <autoresizingMask key=\"autoresizingMask\" widthSizable=\"YES\" heightSizable=\"YES\"/>\n                        <viewLayoutGuide key=\"safeArea\" id=\"6Tk-OE-BBY\"/>\n                        <color key=\"backgroundColor\" systemColor=\"systemBackgroundColor\"/>\n                    </view>\n                    <navigationItem key=\"navigationItem\" id=\"eAW-TI-3lC\"/>\n                </viewController>\n                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"dkx-z0-nzr\" sceneMemberID=\"firstResponder\"/>\n            </objects>\n            <point key=\"canvasLocation\" x=\"1055.7251908396945\" y=\"-2.1126760563380285\"/>\n        </scene>\n        <!--Navigation Controller-->\n        <scene sceneID=\"fwe-8Y-cX4\">\n            <objects>\n                <navigationController automaticallyAdjustsScrollViewInsets=\"NO\" id=\"dGJ-hY-XG2\" sceneMemberID=\"viewController\">\n                    <toolbarItems/>\n                    <navigationBar key=\"navigationBar\" contentMode=\"scaleToFill\" id=\"dId-EU-7Zr\">\n                        <rect key=\"frame\" x=\"0.0\" y=\"59\" width=\"393\" height=\"44\"/>\n                        <autoresizingMask key=\"autoresizingMask\"/>\n                    </navigationBar>\n                    <nil name=\"viewControllers\"/>\n                    <connections>\n                        <segue destination=\"BYZ-38-t0r\" kind=\"relationship\" relationship=\"rootViewController\" id=\"sWM-g7-Rgd\"/>\n                    </connections>\n                </navigationController>\n                <placeholder placeholderIdentifier=\"IBFirstResponder\" id=\"g35-9G-e04\" userLabel=\"First Responder\" customClass=\"UIResponder\" sceneMemberID=\"firstResponder\"/>\n            </objects>\n            <point key=\"canvasLocation\" x=\"129.00763358778624\" y=\"-2.1126760563380285\"/>\n        </scene>\n    </scenes>\n    <resources>\n        <systemColor name=\"systemBackgroundColor\">\n            <color white=\"1\" alpha=\"1\" colorSpace=\"custom\" customColorSpace=\"genericGamma22GrayColorSpace\"/>\n        </systemColor>\n    </resources>\n</document>\n"}]},{"isFile":false,"name":"Assets.xcassets","path":"/TextEditorApp/Assets.xcassets","children":[{"isFile":false,"name":"AppIcon.appiconset","path":"/TextEditorApp/Assets.xcassets/AppIcon.appiconset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/TextEditorApp/Assets.xcassets/AppIcon.appiconset/Contents.json","content":"{\n  \"images\" : [\n    {\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":false,"name":"AccentColor.colorset","path":"/TextEditorApp/Assets.xcassets/AccentColor.colorset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/TextEditorApp/Assets.xcassets/AccentColor.colorset/Contents.json","content":"{\n  \"colors\" : [\n    {\n      \"idiom\" : \"universal\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/TextEditorApp/Assets.xcassets/Contents.json","content":"{\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"swift","name":"AppDelegate.swift","path":"/TextEditorApp/AppDelegate.swift","content":"/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIKit\n\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(_: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // Override point for customization after application launch.\n        return true\n    }\n\n    // MARK: UISceneSession Lifecycle\n\n    func application(_: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n        // Called when a new scene session is being created.\n        // Use this method to select a configuration to create the new scene with.\n        return UISceneConfiguration(name: \"Default Configuration\", sessionRole: connectingSceneSession.role)\n    }\n\n    func application(_: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {\n        // Called when the user discards a scene session.\n        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.\n        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"markup","name":"Info.plist","path":"/TextEditorApp/Info.plist","content":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>UIApplicationSceneManifest</key>\n\t<dict>\n\t\t<key>UIApplicationSupportsMultipleScenes</key>\n\t\t<false/>\n\t\t<key>UISceneConfigurations</key>\n\t\t<dict>\n\t\t\t<key>UIWindowSceneSessionRoleApplication</key>\n\t\t\t<array>\n\t\t\t\t<dict>\n\t\t\t\t\t<key>UISceneConfigurationName</key>\n\t\t\t\t\t<string>Default Configuration</string>\n\t\t\t\t\t<key>UISceneDelegateClassName</key>\n\t\t\t\t\t<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>\n\t\t\t\t\t<key>UISceneStoryboardFile</key>\n\t\t\t\t\t<string>Main</string>\n\t\t\t\t</dict>\n\t\t\t</array>\n\t\t</dict>\n\t</dict>\n</dict>\n</plist>\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"SceneDelegate.swift","path":"/TextEditorApp/SceneDelegate.swift","content":"/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    var window: UIWindow?\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.\n        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.\n        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).\n        guard let _ = (scene as? UIWindowScene) else { return }\n    }\n\n    func sceneDidDisconnect(_: UIScene) {\n        // Called as the scene is being released by the system.\n        // This occurs shortly after the scene enters the background, or when its session is discarded.\n        // Release any resources associated with this scene that can be re-created the next time the scene connects.\n        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).\n    }\n\n    func sceneDidBecomeActive(_: UIScene) {\n        // Called when the scene has moved from an inactive state to an active state.\n        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.\n    }\n\n    func sceneWillResignActive(_: UIScene) {\n        // Called when the scene will move from an active state to an inactive state.\n        // This may occur due to temporary interruptions (ex. an incoming phone call).\n    }\n\n    func sceneWillEnterForeground(_: UIScene) {\n        // Called as the scene transitions from the background to the foreground.\n        // Use this method to undo the changes made on entering the background.\n    }\n\n    func sceneDidEnterBackground(_: UIScene) {\n        // Called as the scene transitions from the foreground to the background.\n        // Use this method to save data, release shared resources, and store enough scene-specific state information\n        // to restore the scene back to its current state.\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ViewController.swift","path":"/TextEditorApp/ViewController.swift","content":"/*\n * Copyright 2023 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIKit\n\nclass ViewController: UIViewController {\n    private let textEditorButton: UIButton = {\n        let result = UIButton()\n        result.translatesAutoresizingMaskIntoConstraints = false\n        result.setTitle(\"Text Editor\", for: .normal)\n        result.setTitleColor(UIColor.black, for: .normal)\n        result.setTitleColor(UIColor.gray, for: .highlighted)\n        result.layer.borderColor = UIColor.black.cgColor\n        result.layer.borderWidth = 1\n        result.layer.cornerRadius = 5\n        return result\n    }()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        self.title = \"Yorkie Sample\"\n\n        self.view.addSubview(self.textEditorButton)\n        self.textEditorButton.topAnchor.constraint(equalTo: self.view.layoutMarginsGuide.topAnchor, constant: 50).isActive = true\n        self.textEditorButton.leadingAnchor.constraint(equalTo: self.view.layoutMarginsGuide.leadingAnchor).isActive = true\n        self.textEditorButton.trailingAnchor.constraint(equalTo: self.view.layoutMarginsGuide.trailingAnchor).isActive = true\n        self.textEditorButton.heightAnchor.constraint(equalToConstant: 50).isActive = true\n\n        self.textEditorButton.addTarget(self, action: #selector(self.didTapTextEditorButton), for: .touchUpInside)\n    }\n\n    @objc private func didTapTextEditorButton() {\n        let viewController = TextEditorViewController()\n\n        self.navigationController?.pushViewController(viewController, animated: true)\n    }\n}\n"}]}]}