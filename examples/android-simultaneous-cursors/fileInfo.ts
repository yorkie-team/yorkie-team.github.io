import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"simultaneous-cursors","path":"/","children":[{"isFile":false,"name":"src","path":"/src","children":[{"isFile":false,"name":"main","path":"/src/main","children":[{"isFile":false,"name":"java","path":"/src/main/java","children":[{"isFile":false,"name":"dev","path":"/src/main/java/dev","children":[{"isFile":false,"name":"yorkie","path":"/src/main/java/dev/yorkie","children":[{"isFile":false,"name":"example","path":"/src/main/java/dev/yorkie/example","children":[{"isFile":false,"name":"simultaneouscursors","path":"/src/main/java/dev/yorkie/example/simultaneouscursors","children":[{"isFile":false,"name":"ui","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui","children":[{"isFile":false,"name":"theme","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/theme","children":[{"isFile":true,"isOpen":false,"language":"kotlin","name":"Color.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/theme/Color.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple200 = Color(0xFFBB86FC)\nval Purple500 = Color(0xFF6200EE)\nval Purple700 = Color(0xFF3700B3)\nval Teal200 = Color(0xFF03DAC5)\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"Theme.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/theme/Theme.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.theme\n\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.darkColors\nimport androidx.compose.material.lightColors\nimport androidx.compose.runtime.Composable\n\nprivate val DarkColorPalette = darkColors(\n    primary = Purple200,\n    primaryVariant = Purple700,\n    secondary = Teal200,\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = Purple500,\n    primaryVariant = Purple700,\n    secondary = Teal200,\n)\n\n@Composable\nfun SimultaneousCursorsTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit,\n) {\n    val colors = if (darkTheme) {\n        DarkColorPalette\n    } else {\n        LightColorPalette\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = Typography,\n        content = content,\n    )\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"Type.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/theme/Type.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.theme\n\nimport androidx.compose.material.Typography\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.sp\n\nval Typography = Typography(\n    body1 = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp,\n    ),\n)\n"}]},{"isFile":false,"name":"simultaneouscursors","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors","children":[{"isFile":false,"name":"navigation","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/navigation","children":[{"isFile":true,"isOpen":false,"language":"kotlin","name":"SimultaneousCursorsNavigation.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/navigation/SimultaneousCursorsNavigation.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors.navigation\n\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport androidx.navigation.NavGraphBuilder\nimport androidx.navigation.NavType\nimport androidx.navigation.compose.composable\nimport androidx.navigation.navArgument\nimport dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors.SimultaneousCursorsScreen\nimport dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors.SimultaneousCursorsViewModel\nimport java.net.URLEncoder\nimport kotlin.text.Charsets.UTF_8\n\nconst val DOCUMENT_KEY_ARG = \"documentKey\"\nconst val SIMULTANEOUS_CURSORS_BASE_ROUTE = \"simultaneous_cursors_route\"\nconst val SIMULTANEOUS_CURSORS_ROUTE =\n    \"$SIMULTANEOUS_CURSORS_BASE_ROUTE?$DOCUMENT_KEY_ARG={$DOCUMENT_KEY_ARG}\"\n\nfun NavController.navigateToSimultaneousCursors(documentKey: String) {\n    val encodedDocumentKey = URLEncoder.encode(documentKey, UTF_8.name())\n    val route = \"$SIMULTANEOUS_CURSORS_BASE_ROUTE?${DOCUMENT_KEY_ARG}=$encodedDocumentKey\"\n    navigate(route = route)\n}\n\nfun NavGraphBuilder.simultaneousCursorsScreen() {\n    composable(\n        route = SIMULTANEOUS_CURSORS_ROUTE,\n        arguments = listOf(\n            navArgument(DOCUMENT_KEY_ARG) {\n                defaultValue = null\n                nullable = true\n                type = NavType.StringType\n            },\n        ),\n    ) { backStackEntry ->\n        val documentKey = backStackEntry.arguments?.getString(DOCUMENT_KEY_ARG)\n\n        val viewModel: SimultaneousCursorsViewModel = viewModel(\n            factory = SimultaneousCursorsViewModel.provideFactory(documentKey),\n        )\n\n        SimultaneousCursorsScreen(\n            viewModel = viewModel,\n        )\n    }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"AnimatedCursor.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/AnimatedCursor.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\nimport androidx.compose.animation.core.LinearEasing\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.Canvas\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.core.graphics.toColorInt\nimport kotlin.math.roundToInt\nimport kotlin.random.Random\nimport kotlinx.coroutines.delay\n\n@Composable\nfun AnimatedCursor(clientPresence: ClientPresence, modifier: Modifier = Modifier) {\n    val density = LocalDensity.current\n    val cursorSize = 24.dp\n\n    // Animate cursor position\n    val animatedX by animateFloatAsState(\n        targetValue = clientPresence.presence.cursor.xPos.toFloat(),\n        animationSpec = tween(durationMillis = 10),\n        label = \"cursor_x\",\n    )\n\n    val animatedY by animateFloatAsState(\n        targetValue = clientPresence.presence.cursor.yPos.toFloat(),\n        animationSpec = tween(durationMillis = 10),\n        label = \"cursor_y\",\n    )\n\n    // Animate scale for pointer down effect\n    val scale by animateFloatAsState(\n        targetValue = if (clientPresence.presence.pointerDown) 1.2f else 1.0f,\n        animationSpec = tween(durationMillis = 150),\n        label = \"cursor_scale\",\n    )\n\n    val halfCursorPx = with(density) { cursorSize.toPx() / 2 }\n\n    Box(\n        modifier = modifier\n            .graphicsLayer {\n                translationX = animatedX - halfCursorPx\n                translationY = animatedY - halfCursorPx\n            },\n    ) {\n        // Main cursor\n        CursorIcon(\n            cursorShape = clientPresence.presence.cursorShape,\n            modifier = Modifier.size((cursorSize.value * scale).dp),\n        )\n\n        // User name label positioned above the cursor\n        val name = clientPresence.presence.name ?: \"Anonymous\"\n        val color = clientPresence.presence.color?.toColor() ?: Color.Black\n        Text(\n            text = if (clientPresence.presence.isMyself) {\n                \"$name (Me)\"\n            } else {\n                name\n            },\n            fontSize = 10.sp,\n            fontWeight = FontWeight.Medium,\n            color = Color.White,\n            modifier = Modifier\n                .offset(x = 8.dp, y = (-16).dp)\n                .clip(RoundedCornerShape(4.dp))\n                .background(color.copy(alpha = 0.9f))\n                .padding(horizontal = 4.dp, vertical = 2.dp),\n        )\n\n        // Special effects for certain cursor shapes\n        when (clientPresence.presence.cursorShape) {\n            CursorShape.HEART, CursorShape.THUMBS -> {\n                if (!clientPresence.presence.pointerDown) {\n                    AnimationEffect(\n                        cursorShape = clientPresence.presence.cursorShape,\n                    )\n                }\n            }\n\n            CursorShape.PEN -> {\n                if (clientPresence.presence.pointerDown) {\n                    PenTrail(\n                        color = Color.Black,\n                    )\n                }\n            }\n\n            else -> {\n                Unit\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun AnimationEffect(cursorShape: CursorShape, modifier: Modifier = Modifier) {\n    var particles by remember { mutableStateOf(emptyList<FloatingParticle>()) }\n\n    // Generate new particles when effect starts\n    LaunchedEffect(Unit) {\n        val newParticles = (1..5).map { index ->\n            FloatingParticle(\n                id = index,\n                startX = Random.nextFloat() * 60f - 30f,\n                startY = -30f,\n                targetY = -200f - Random.nextFloat() * 60f,\n                horizontalDrift = Random.nextFloat() * 20f - 10f,\n                delay = index * 100L,\n            )\n        }\n        particles = newParticles\n    }\n\n    // Render each particle\n    particles.forEach { particle ->\n        FloatingParticleView(\n            particle = particle,\n            cursorShape = cursorShape,\n            modifier = modifier,\n        )\n    }\n}\n\ndata class FloatingParticle(\n    val id: Int,\n    val startX: Float,\n    val startY: Float,\n    val targetY: Float,\n    val horizontalDrift: Float,\n    val delay: Long,\n)\n\n@Composable\nprivate fun FloatingParticleView(\n    particle: FloatingParticle,\n    cursorShape: CursorShape,\n    modifier: Modifier = Modifier,\n) {\n    var animationStarted by remember { mutableStateOf(false) }\n\n    // Start animation after delay\n    LaunchedEffect(particle.id) {\n        delay(particle.delay)\n        animationStarted = true\n    }\n\n    // Animate vertical position\n    val animatedY by animateFloatAsState(\n        targetValue = if (animationStarted) {\n            particle.targetY\n        } else {\n            particle.startY\n        },\n        animationSpec = tween(durationMillis = 800, easing = LinearEasing),\n        label = \"particle_y_${particle.id}\",\n    )\n\n    // Animate horizontal drift\n    val animatedX by animateFloatAsState(\n        targetValue = if (animationStarted) {\n            particle.startX + particle.horizontalDrift\n        } else {\n            particle.startX\n        },\n        animationSpec = tween(durationMillis = 800, easing = LinearEasing),\n        label = \"particle_x_${particle.id}\",\n    )\n\n    // Animate opacity (fade out as it goes up)\n    val alpha by animateFloatAsState(\n        targetValue = if (animationStarted) 0f else 1f,\n        animationSpec = tween(durationMillis = 800, easing = LinearEasing),\n        label = \"particle_alpha_${particle.id}\",\n    )\n\n    // Animate scale (slight grow and shrink)\n    val scale by animateFloatAsState(\n        targetValue = if (animationStarted) 0.8f else 1.2f,\n        animationSpec = tween(durationMillis = 800, easing = LinearEasing),\n        label = \"particle_scale_${particle.id}\",\n    )\n\n    Box(\n        modifier = modifier\n            .offset { IntOffset(animatedX.roundToInt(), animatedY.roundToInt()) }\n            .graphicsLayer {\n                this.alpha = alpha\n                this.scaleX = scale\n                this.scaleY = scale\n            },\n    ) {\n        CursorIcon(\n            cursorShape = cursorShape,\n            modifier = Modifier\n                .size(20.dp),\n        )\n    }\n}\n\n@Composable\nprivate fun PenTrail(color: Color, modifier: Modifier = Modifier) {\n    Canvas(\n        modifier = modifier.size(8.dp),\n    ) {\n        drawCircle(\n            color = color,\n            radius = size.width / 4,\n            center = Offset(size.width / 2, size.height / 2),\n        )\n    }\n}\n\nprivate fun String.toColor(): Color {\n    return Color(this.toColorInt())\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"CursorIcon.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/CursorIcon.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\nimport androidx.compose.foundation.Canvas\nimport androidx.compose.material.Icon\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Favorite\nimport androidx.compose.material.icons.filled.ThumbUp\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.drawscope.DrawScope\nimport androidx.compose.ui.graphics.drawscope.rotate\n\n@Composable\nfun CursorIcon(cursorShape: CursorShape, modifier: Modifier = Modifier) {\n    when (cursorShape) {\n        CursorShape.HEART -> {\n            Icon(\n                imageVector = Icons.Filled.Favorite,\n                contentDescription = \"Heart\",\n                modifier = modifier,\n                tint = Color.Red,\n            )\n        }\n\n        CursorShape.THUMBS -> {\n            Icon(\n                imageVector = Icons.Filled.ThumbUp,\n                contentDescription = \"Thumbs Up\",\n                modifier = modifier,\n                tint = Color.Yellow,\n            )\n        }\n\n        CursorShape.PEN -> {\n            Canvas(modifier = modifier) {\n                drawPen()\n            }\n        }\n\n        CursorShape.CURSOR -> {\n            Canvas(modifier = modifier) {\n                drawCursor()\n            }\n        }\n    }\n}\n\nprivate fun DrawScope.drawCursor() {\n    val width = size.width\n    val height = size.height\n\n    // We rotate around the cursor’s center\n    rotate(degrees = 40f, pivot = Offset(width / 2, height / 2)) {\n        val path = Path().apply {\n            // Tail (left point)\n            moveTo(width * 0.1f, height * 0.5f)\n\n            // Top wing\n            lineTo(width * 0.9f, height * 0.1f)\n\n            // Mid inner fold\n            lineTo(width * 0.65f, height * 0.5f)\n\n            // Bottom wing\n            lineTo(width * 0.9f, height * 0.9f)\n\n            // Back to tail\n            close()\n        }\n\n        drawPath(path = path, color = Color.Black)\n    }\n}\n\nprivate fun DrawScope.drawHeart() {\n    val path = Path().apply {\n        val width = size.width\n        val height = size.height\n\n        // Left curve\n        moveTo(width * 0.5f, height * 0.2f)\n\n        // Left lobe: cubic curve to bottom tip\n        cubicTo(\n            width * 0.15f,\n            // control point 1 (left-top)\n            height * 0.0f,\n            width * 0.0f,\n            // control point 2 (left-inner)\n            height * 0.35f,\n            width * 0.5f,\n            // end (bottom tip)\n            height * 0.8f,\n        )\n\n        // Right lobe: cubic curve back to top center\n        cubicTo(\n            width * 1.0f,\n            // control point 1 (right-inner)\n            height * 0.35f,\n            width * 0.85f,\n            // control point 2 (right-top)\n            height * 0.0f,\n            width * 0.5f,\n            // back to start\n            height * 0.2f,\n        )\n\n        close()\n    }\n\n    drawPath(\n        path = path,\n        color = Color.Red,\n    )\n}\n\nprivate fun DrawScope.drawPen() {\n    val width = size.width\n    val height = size.height\n\n    // We rotate around the pen’s center\n    rotate(degrees = 40f, pivot = Offset(width / 2, height / 2)) {\n        // Pen body (rectangle)\n        val body = Path().apply {\n            moveTo(width * 0.35f, height * 0.1f)\n            lineTo(width * 0.65f, height * 0.1f)\n            lineTo(width * 0.65f, height * 0.55f)\n            lineTo(width * 0.35f, height * 0.55f)\n            close()\n        }\n\n        // Nib (triangle pointing down)\n        val nib = Path().apply {\n            moveTo(width * 0.35f, height * 0.55f)\n            lineTo(width * 0.65f, height * 0.55f)\n            lineTo(width * 0.50f, height * 0.90f) // tip\n            close()\n        }\n\n        // Hole in nib (small circle)\n        val holeCenter = Offset(width * 0.50f, height * 0.70f)\n        val holeRadius = width * 0.05f\n\n        drawPath(path = body, color = Color.Black)\n        drawPath(path = nib, color = Color.Gray)\n        drawCircle(color = Color.Black, radius = holeRadius, center = holeCenter)\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"CursorModels.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/CursorModels.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\ndata class CursorPosition(\n    val xPos: Double = 0.0,\n    val yPos: Double = 0.0,\n)\n\ndata class CursorPresence(\n    val name: String? = null,\n    val cursorShape: CursorShape = CursorShape.CURSOR,\n    val cursor: CursorPosition = CursorPosition(),\n    val pointerDown: Boolean = false,\n    val isMyself: Boolean = false,\n    val color: String? = null,\n)\n\ndata class ClientPresence(\n    val clientID: String,\n    val presence: CursorPresence,\n)\n\nenum class CursorShape(val displayName: String, val iconName: String) {\n    HEART(\"Heart\", \"heart\"),\n    THUMBS(\"Thumbs\", \"thumbs\"),\n    PEN(\"Pen\", \"pen\"),\n    CURSOR(\"Cursor\", \"cursor\"),\n    ;\n\n    companion object {\n        fun fromString(value: String): CursorShape {\n            return entries.find { it.iconName == value } ?: CURSOR\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"CursorSelections.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/CursorSelections.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport dev.yorkie.example.simultaneouscursors.R\n\n@Composable\nfun CursorSelections(\n    selectedCursorShape: CursorShape,\n    clientsCount: Int,\n    onCursorShapeSelect: (CursorShape) -> Unit,\n    modifier: Modifier = Modifier,\n) {\n    Column(\n        modifier = modifier\n            .padding(16.dp)\n            .background(\n                color = MaterialTheme.colors.surface,\n                shape = RoundedCornerShape(12.dp),\n            )\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n    ) {\n        // Cursor shape selection\n        Row(\n            horizontalArrangement = Arrangement.spacedBy(12.dp),\n            verticalAlignment = Alignment.CenterVertically,\n        ) {\n            CursorShape.entries.forEach { shape ->\n                CursorShapeButton(\n                    cursorShape = shape,\n                    isSelected = selectedCursorShape == shape,\n                    onClick = { onCursorShapeSelect(shape) },\n                )\n            }\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Users count\n        Text(\n            text = if (clientsCount == 1) {\n                stringResource(R.string.users_count_single)\n            } else {\n                stringResource(R.string.users_count_multiple, clientsCount)\n            },\n            style = MaterialTheme.typography.body2,\n            fontWeight = FontWeight.Medium,\n            color = MaterialTheme.colors.onSurface,\n        )\n    }\n}\n\n@Composable\nprivate fun CursorShapeButton(\n    cursorShape: CursorShape,\n    isSelected: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n) {\n    val backgroundColor = if (isSelected) {\n        MaterialTheme.colors.primary.copy(alpha = 0.1f)\n    } else {\n        MaterialTheme.colors.surface\n    }\n\n    val borderColor = if (isSelected) {\n        MaterialTheme.colors.primary\n    } else {\n        MaterialTheme.colors.onSurface.copy(alpha = 0.3f)\n    }\n\n    Box(\n        modifier = modifier\n            .size(48.dp)\n            .clip(RoundedCornerShape(8.dp))\n            .background(backgroundColor)\n            .border(\n                width = 2.dp,\n                color = borderColor,\n                shape = RoundedCornerShape(8.dp),\n            )\n            .clickable { onClick() }\n            .padding(8.dp),\n        contentAlignment = Alignment.Center,\n    ) {\n        CursorIcon(\n            cursorShape = cursorShape,\n            modifier = Modifier\n                .size(24.dp),\n        )\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"DrawingCanvas.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/DrawingCanvas.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\nimport androidx.compose.foundation.Canvas\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.StrokeCap\nimport androidx.compose.ui.graphics.StrokeJoin\nimport androidx.compose.ui.graphics.drawscope.Stroke\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun DrawingCanvas(\n    modifier: Modifier = Modifier,\n    currentDrawingPreview: List<Offset> = emptyList(),\n    activeDrawingLines: Map<String, List<Offset>> = emptyMap(),\n) {\n    Canvas(\n        modifier = modifier.fillMaxSize(),\n    ) {\n        // No persistent drawing lines anymore - they disappear when drawing stops\n\n        // Draw active drawing lines from other clients (being drawn in real-time)\n        activeDrawingLines.forEach { (clientId, points) ->\n            if (points.size >= 2) {\n                val clientColor = Color.Black\n                val path = Path()\n\n                // Start the path at the first point\n                val firstPoint = points.first()\n                path.moveTo(firstPoint.x, firstPoint.y)\n\n                // Add lines to subsequent points\n                points.drop(1).forEach { point ->\n                    path.lineTo(point.x, point.y)\n                }\n\n                // Draw the active path with a slightly more transparent style\n                drawPath(\n                    path = path,\n                    color = clientColor.copy(alpha = 0.7f),\n                    style = Stroke(\n                        width = 4.dp.toPx(),\n                        cap = StrokeCap.Round,\n                        join = StrokeJoin.Round,\n                    ),\n                )\n            }\n        }\n\n        // Draw current drawing preview (while user is actively drawing)\n        if (currentDrawingPreview.size >= 2) {\n            val path = Path()\n\n            // Start the path at the first point\n            val firstPoint = currentDrawingPreview.first()\n            path.moveTo(firstPoint.x, firstPoint.y)\n\n            // Add lines to subsequent points\n            currentDrawingPreview.drop(1).forEach { point ->\n                path.lineTo(point.x, point.y)\n            }\n\n            // Draw the preview path with a slightly different style\n            drawPath(\n                path = path,\n                color = Color.Gray,\n                style = Stroke(\n                    width = 4.dp.toPx(),\n                    cap = StrokeCap.Round,\n                    join = StrokeJoin.Round,\n                ),\n            )\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"SimultaneousCursorsScreen.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/SimultaneousCursorsScreen.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectDragGestures\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.CircularProgressIndicator\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.layout.onSizeChanged\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.IntSize\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun SimultaneousCursorsScreen(\n    modifier: Modifier = Modifier,\n    viewModel: SimultaneousCursorsViewModel,\n) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    SimultaneousCursorsScreen(\n        uiState = uiState,\n        onSizeChanged = { size ->\n            viewModel.updateScreenDimensions(\n                size.width.toFloat(),\n                size.height.toFloat(),\n            )\n        },\n        onDragStart = viewModel::startDragging,\n        onDragEnd = viewModel::endDragging,\n        onDrag = viewModel::startDragging,\n        onPresDown = viewModel::pressDown,\n        onRelease = viewModel::release,\n        onCursorShapeSelect = viewModel::updateCursorShape,\n        modifier = modifier,\n    )\n}\n\n@Composable\nfun SimultaneousCursorsScreen(\n    uiState: SimultaneousCursorsUiState,\n    onSizeChanged: (IntSize) -> Unit,\n    onDragStart: (Offset) -> Unit,\n    onDragEnd: () -> Unit,\n    onDrag: (Offset) -> Unit,\n    onPresDown: (Offset) -> Unit,\n    onRelease: () -> Unit,\n    onCursorShapeSelect: (CursorShape) -> Unit,\n    modifier: Modifier = Modifier,\n) {\n    when {\n        uiState.isLoading -> {\n            Box(\n                modifier = modifier.fillMaxSize(),\n                contentAlignment = Alignment.Center,\n            ) {\n                CircularProgressIndicator()\n            }\n        }\n\n        uiState.error != null -> {\n            Box(\n                modifier = modifier.fillMaxSize(),\n                contentAlignment = Alignment.Center,\n            ) {\n                Text(\n                    text = \"Error: ${uiState.error}\",\n                    color = MaterialTheme.colors.error,\n                    textAlign = TextAlign.Center,\n                    modifier = Modifier.padding(16.dp),\n                )\n            }\n        }\n\n        else -> {\n            Box(\n                modifier = modifier\n                    .fillMaxSize()\n                    .background(MaterialTheme.colors.background)\n                    .onSizeChanged { size ->\n                        onSizeChanged(size)\n                    }\n                    .pointerInput(Unit) {\n                        detectDragGestures(\n                            onDragStart = onDragStart,\n                            onDragEnd = onDragEnd,\n                            onDrag = { change, _ ->\n                                onDrag(change.position)\n                            },\n                        )\n                    }\n                    .pointerInput(Unit) {\n                        detectTapGestures(\n                            onPress = { offset ->\n                                onPresDown(offset)\n                                try {\n                                    tryAwaitRelease()\n                                } finally {\n                                    onRelease()\n                                }\n                            },\n                        )\n                    },\n            ) {\n                // Drawing canvas for pen lines (behind cursors)\n                DrawingCanvas(\n                    currentDrawingPreview = uiState.currentDrawingLinePreview,\n                    activeDrawingLines = uiState.activeDrawingLines,\n                )\n\n                // Render all client cursors\n                uiState.clients.forEach { clientPresence ->\n                    if (clientPresence.presence.cursor.xPos > 0 ||\n                        clientPresence.presence.cursor.yPos > 0\n                    ) {\n                        AnimatedCursor(\n                            clientPresence = clientPresence,\n                            modifier = Modifier,\n                        )\n                    }\n                }\n\n                // Cursor selection UI at the bottom\n                CursorSelections(\n                    selectedCursorShape = uiState.selectedCursorShape,\n                    clientsCount = uiState.clients.size,\n                    onCursorShapeSelect = onCursorShapeSelect,\n                    modifier = Modifier\n                        .align(Alignment.BottomCenter)\n                        .padding(16.dp),\n                )\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"SimultaneousCursorsViewModel.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/simultaneouscursors/SimultaneousCursorsViewModel.kt","content":"package dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors\n\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.graphics.Color\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport com.google.gson.GsonBuilder\nimport com.google.gson.JsonSyntaxException\nimport com.google.gson.reflect.TypeToken\nimport dev.yorkie.core.Client\nimport dev.yorkie.document.Document\nimport dev.yorkie.document.Document.Event.PresenceChanged\nimport dev.yorkie.example.simultaneouscursors.BuildConfig\nimport java.net.URLDecoder\nimport kotlin.random.Random\nimport kotlin.text.Charsets.UTF_8\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.filterIsInstance\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\n\ndata class SimultaneousCursorsUiState(\n    val clients: List<ClientPresence> = emptyList(),\n    val selectedCursorShape: CursorShape = CursorShape.CURSOR,\n    val currentDrawingLinePreview: List<Offset> = emptyList(),\n    val activeDrawingLines: Map<String, List<Offset>> = emptyMap(),\n    val isLoading: Boolean = false,\n    val error: String? = null,\n)\n\nclass SimultaneousCursorsViewModel(\n    documentKey: String,\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(\n        SimultaneousCursorsUiState(\n            isLoading = true,\n        ),\n    )\n    val uiState: StateFlow<SimultaneousCursorsUiState> = _uiState.asStateFlow()\n\n    private val clientPresences = mutableMapOf<String, CursorPresence>()\n    private val clientActiveDrawingLines = mutableMapOf<String, MutableList<Offset>>()\n\n    // Current screen dimensions\n    private var currentScreenWidth: Float = 0f\n    private var currentScreenHeight: Float = 0f\n\n    // Current drawing state\n    private var currentDrawingLine: MutableList<Offset> = mutableListOf()\n    private var isDrawing: Boolean = false\n\n    private var myClientId = \"\"\n\n    private val gson = GsonBuilder().create()\n\n    private val client = Client(\n        options = Client.Options(\n            apiKey = BuildConfig.YORKIE_API_KEY,\n        ),\n        host = BuildConfig.YORKIE_SERVER_URL,\n    )\n\n    private val document = Document(documentKey)\n\n    init {\n        setupYorkieConnection()\n    }\n\n    private fun setupYorkieConnection() {\n        viewModelScope.launch {\n            connectAndAttachDocument()\n        }\n\n        viewModelScope.launch {\n            launch {\n                document.events.filterIsInstance<PresenceChanged>().collect { event ->\n                    when (event) {\n                        is PresenceChanged.MyPresence.Initialized -> {\n                            event.initialized.forEach { (key, value) ->\n                                updateClientPresence(\n                                    key.value,\n                                    value,\n                                )\n                            }\n                        }\n\n                        is PresenceChanged.Others.PresenceChanged -> {\n                            updateClientPresence(\n                                event.changed.actorID.value,\n                                event.changed.presence,\n                            )\n                        }\n\n                        is PresenceChanged.Others.Unwatched -> {\n                            removeClientPresence(event.changed.actorID.value)\n                        }\n\n                        is PresenceChanged.MyPresence.PresenceChanged -> {\n                            myClientId = event.changed.actorID.value\n                            updateClientPresence(\n                                event.changed.actorID.value,\n                                event.changed.presence,\n                            )\n                        }\n\n                        else -> {}\n                    }\n                }\n            }\n        }\n    }\n\n    private suspend fun connectAndAttachDocument() {\n        try {\n            val activateAsyncResult = client.activateAsync().await()\n            if (!activateAsyncResult.isSuccess) {\n                _uiState.value = _uiState.value.copy(\n                    isLoading = false,\n                    error = \"Failed to connect to Yorkie server\",\n                )\n                Timber.e(\n                    \"${this@SimultaneousCursorsViewModel::class.java.name}#init: %s\",\n                    \"Failed to connect to Yorkie server ${BuildConfig.YORKIE_SERVER_URL}, \" +\n                        \"Error: ${activateAsyncResult.exceptionOrNull()}\",\n                )\n                return\n            }\n\n            val attachDocumentResult = client.attachDocument(\n                document = document,\n                initialPresence = mapOf(\n                    \"name\" to \"\\\"${generateDisplayName()}\\\"\",\n                    \"color\" to \"\\\"${randomColorString()}\\\"\",\n                    \"cursorShape\" to \"\\\"cursor\\\"\",\n                    \"cursor\" to gson.toJson(\n                        mapOf(\n                            \"xPos\" to 0.0,\n                            \"yPos\" to 0.0,\n                        ),\n                    ),\n                    \"pointerDown\" to \"false\",\n                ),\n            ).await()\n            if (!attachDocumentResult.isSuccess) {\n                _uiState.value = _uiState.value.copy(\n                    isLoading = false,\n                    error = \"Failed to attach document to Yorkie server\",\n                )\n                Timber.e(\n                    \"${this@SimultaneousCursorsViewModel::class.java.name}#init: %s\",\n                    \"Failed to attach document ${document.getKey()} \" +\n                        \"to Yorkie server ${BuildConfig.YORKIE_SERVER_URL}, \" +\n                        \"Error: ${attachDocumentResult.exceptionOrNull()}\",\n                )\n                return\n            }\n\n            Timber.i(\n                \"${this@SimultaneousCursorsViewModel::class.java.name}#init: %s\",\n                \"Connected to Yorkie server ${BuildConfig.YORKIE_SERVER_URL} \" +\n                    \"with document ${document.getKey()}\",\n            )\n\n            _uiState.value = _uiState.value.copy(\n                isLoading = false,\n            )\n        } catch (e: Exception) {\n            _uiState.value = _uiState.value.copy(\n                isLoading = false,\n                error = \"Failed to connect: ${e.message}\",\n            )\n            Timber.e(\n                \"${this@SimultaneousCursorsViewModel::class.java.name}#init: %s\",\n                e.message ?: \"Unknown error occurred\",\n            )\n        }\n    }\n\n    private fun updateClientPresence(clientId: String, presenceData: Map<String, String>) {\n        val name = try {\n            gson.fromJson(presenceData[\"name\"], String::class.java)\n        } catch (e: JsonSyntaxException) {\n            null\n        }\n        val color = try {\n            gson.fromJson(presenceData[\"color\"], String::class.java)\n        } catch (e: JsonSyntaxException) {\n            null\n        }\n        val cursorShape = CursorShape.fromString(\n            gson.fromJson(presenceData[\"cursorShape\"], String::class.java),\n        )\n\n        val cursor: Map<String, *> = gson.fromJson(\n            presenceData[\"cursor\"],\n            object : TypeToken<Map<String, *>>() {}.type,\n        )\n        val normalizedXPos = (cursor[\"xPos\"] as? Double) ?: 0.0\n        val normalizedYPos = (cursor[\"yPos\"] as? Double) ?: 0.0\n        val pointerDown = presenceData[\"pointerDown\"]?.toBooleanStrictOrNull() ?: false\n\n        // Convert normalized coordinates (0-1 range) to current screen coordinates\n        val xPos = if (currentScreenWidth > 0) {\n            normalizedXPos * currentScreenWidth\n        } else {\n            normalizedXPos\n        }\n        val yPos = if (currentScreenHeight > 0) {\n            normalizedYPos * currentScreenHeight\n        } else {\n            normalizedYPos\n        }\n\n        val cursorPresence = CursorPresence(\n            name = name,\n            cursorShape = cursorShape,\n            cursor = CursorPosition(xPos, yPos),\n            pointerDown = pointerDown,\n            isMyself = clientId == myClientId,\n            color = color,\n        )\n\n        // Get previous presence to check for state changes\n        val previousPresence = clientPresences[clientId]\n        clientPresences[clientId] = cursorPresence\n\n        // Handle pen drawing logic for other clients\n        if (cursorPresence.cursorShape == CursorShape.PEN) {\n            if (cursorPresence.pointerDown) {\n                // Client is drawing - add current position to their active line\n                val activeDrawingLine = clientActiveDrawingLines.getOrPut(\n                    clientId,\n                ) { mutableListOf() }\n                activeDrawingLine.add(Offset(xPos.toFloat(), yPos.toFloat()))\n            } else if (previousPresence?.pointerDown == true && !cursorPresence.pointerDown) {\n                // Client finished drawing - clear the active line (don't save it)\n                clientActiveDrawingLines[clientId] = mutableListOf() // Clear active line\n            }\n        }\n\n        // Update active drawing lines state\n        updateUiState()\n\n        updateClientsList()\n    }\n\n    private fun removeClientPresence(clientId: String) {\n        clientPresences.remove(clientId)\n        clientActiveDrawingLines.remove(clientId)\n        updateUiState()\n        updateClientsList()\n    }\n\n    private fun updateClientsList() {\n        val clientsList = clientPresences.map { (clientId, presence) ->\n            ClientPresence(\n                clientID = clientId,\n                presence = presence,\n            )\n        }\n        _uiState.value = _uiState.value.copy(clients = clientsList)\n    }\n\n    private fun updateUiState() {\n        _uiState.value = _uiState.value.copy(\n            activeDrawingLines = clientActiveDrawingLines.toMap(),\n        )\n    }\n\n    fun updateCursorShape(cursorShape: CursorShape) {\n        _uiState.value = _uiState.value.copy(selectedCursorShape = cursorShape)\n        viewModelScope.launch {\n            document.updateAsync { _, presence ->\n                presence.put(mapOf(\"cursorShape\" to gson.toJson(cursorShape.iconName)))\n            }.await()\n        }\n    }\n\n    private fun updateCursorPosition(x: Float, y: Float) {\n        // Add point to current drawing line if pen is being used and pointer is down\n        if (_uiState.value.selectedCursorShape == CursorShape.PEN && isDrawing) {\n            currentDrawingLine.add(Offset(x, y))\n            _uiState.value = _uiState.value.copy(\n                currentDrawingLinePreview = currentDrawingLine.toList(),\n            )\n        }\n\n        // Normalize coordinates to 0-1 range before sending to server\n        val normalizedX = if (currentScreenWidth > 0) (x / currentScreenWidth).toDouble() else 0.0\n        val normalizedY = if (currentScreenHeight > 0) (y / currentScreenHeight).toDouble() else 0.0\n\n        viewModelScope.launch {\n            document.updateAsync { _, presence ->\n                presence.put(\n                    mapOf(\n                        \"cursor\" to gson.toJson(\n                            mapOf(\n                                \"xPos\" to normalizedX,\n                                \"yPos\" to normalizedY,\n                            ),\n                        ),\n                    ),\n                )\n            }.await()\n        }\n    }\n\n    fun updateScreenDimensions(width: Float, height: Float) {\n        currentScreenWidth = width\n        currentScreenHeight = height\n    }\n\n    fun startDragging(offset: Offset) {\n        if (_uiState.value.selectedCursorShape == CursorShape.PEN) {\n            updateCursorPosition(offset.x, offset.y)\n            viewModelScope.launch {\n                document.updateAsync { _, presence ->\n                    presence.put(mapOf(\"pointerDown\" to \"true\"))\n                }.await()\n            }\n        } else {\n            updateCursorPosition(offset.x, offset.y)\n            viewModelScope.launch {\n                document.updateAsync { _, presence ->\n                    presence.put(mapOf(\"pointerDown\" to \"false\"))\n                }.await()\n            }\n        }\n    }\n\n    fun endDragging() {\n        if (_uiState.value.selectedCursorShape == CursorShape.PEN) {\n            viewModelScope.launch {\n                document.updateAsync { _, presence ->\n                    presence.put(mapOf(\"pointerDown\" to \"false\"))\n                }.await()\n            }\n        }\n    }\n\n    fun pressDown(offset: Offset) {\n        updateCursorPosition(offset.x, offset.y)\n        if (_uiState.value.selectedCursorShape != CursorShape.PEN) {\n            viewModelScope.launch {\n                document.updateAsync { _, presence ->\n                    presence.put(mapOf(\"pointerDown\" to \"true\"))\n                }.await()\n            }\n        }\n    }\n\n    fun release() {\n        if (_uiState.value.selectedCursorShape != CursorShape.PEN) {\n            viewModelScope.launch {\n                document.updateAsync { _, presence ->\n                    presence.put(mapOf(\"pointerDown\" to \"false\"))\n                }.await()\n            }\n        }\n    }\n\n    override fun onCleared() {\n        TerminationScope.launch {\n            client.detachDocument(document).await()\n            client.deactivateAsync().await()\n        }\n        super.onCleared()\n    }\n\n    /**\n     * Generates a user-friendly display name from a clientID.\n     * This creates a consistent name for each client based on their ID.\n     */\n    private fun generateDisplayName(): String {\n        // List of friendly adjectives and nouns for generating names\n        val adjectives = listOf(\n            \"Happy\", \"Swift\", \"Bright\", \"Cool\", \"Smart\", \"Quick\", \"Bold\", \"Calm\",\n            \"Wise\", \"Kind\", \"Brave\", \"Sharp\", \"Gentle\", \"Strong\", \"Clever\", \"Warm\",\n        )\n\n        val nouns = listOf(\n            \"Fox\", \"Eagle\", \"Tiger\", \"Wolf\", \"Bear\", \"Lion\", \"Hawk\", \"Owl\",\n            \"Deer\", \"Rabbit\", \"Dolphin\", \"Whale\", \"Shark\", \"Panda\", \"Koala\", \"Penguin\",\n        )\n\n        return \"${adjectives.random()} ${nouns.random()}\"\n    }\n\n    private fun randomColorString(): String {\n        val hue = Random.nextFloat() * 360f\n        val saturation = 0.6f + Random.nextFloat() * 0.4f\n        val value = 0.25f + Random.nextFloat() * 0.25f\n\n        val color = Color.hsv(hue, saturation, value)\n\n        val r = (color.red * 255).toInt()\n        val g = (color.green * 255).toInt()\n        val b = (color.blue * 255).toInt()\n        return String.format(\"#%02X%02X%02X\", r, g, b)\n    }\n\n    companion object {\n        private val TerminationScope = CoroutineScope(Dispatchers.Main.immediate + SupervisorJob())\n\n        fun provideFactory(documentKey: String?): ViewModelProvider.Factory =\n            object : ViewModelProvider.Factory {\n                override fun <T : ViewModel> create(modelClass: Class<T>): T {\n                    documentKey ?: throw IllegalArgumentException(\"Document Key is not found\")\n                    val decodedDocumentKey = URLDecoder.decode(documentKey, UTF_8.name())\n                    return SimultaneousCursorsViewModel(decodedDocumentKey) as T\n                }\n            }\n    }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"SimultaneousCursorsAppHost.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/ui/SimultaneousCursorsAppHost.kt","content":"package dev.yorkie.example.simultaneouscursors.ui\n\nimport androidx.compose.runtime.Composable\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport dev.yorkie.example.feature.enterdocumentkey.navigation.ENTER_DOCUMENT_KEY_ROUTE\nimport dev.yorkie.example.feature.enterdocumentkey.navigation.enterDocumentKeyScreen\nimport dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors.navigation.navigateToSimultaneousCursors\nimport dev.yorkie.example.simultaneouscursors.ui.simultaneouscursors.navigation.simultaneousCursorsScreen\n\n@Composable\nfun SimultaneousCursorsAppHost(navController: NavHostController) {\n    NavHost(\n        navController = navController,\n        startDestination = ENTER_DOCUMENT_KEY_ROUTE,\n    ) {\n        enterDocumentKeyScreen(\n            onNextClick = {\n                navController.navigateToSimultaneousCursors(it)\n            },\n        )\n\n        simultaneousCursorsScreen()\n    }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"MainActivity.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/MainActivity.kt","content":"package dev.yorkie.example.simultaneouscursors\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.ui.Modifier\nimport androidx.navigation.compose.rememberNavController\nimport dev.yorkie.example.simultaneouscursors.ui.SimultaneousCursorsAppHost\nimport dev.yorkie.example.simultaneouscursors.ui.theme.SimultaneousCursorsTheme\n\nclass MainActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            SimultaneousCursorsTheme {\n                Surface(\n                    modifier = Modifier\n                        .fillMaxSize(),\n                    color = MaterialTheme.colors.background,\n                ) {\n                    SimultaneousCursorsAppHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"MainApplication.kt","path":"/src/main/java/dev/yorkie/example/simultaneouscursors/MainApplication.kt","content":"package dev.yorkie.example.simultaneouscursors\n\nimport android.app.Application\nimport dev.yorkie.example.core.common.logger.YorkieLogger\n\nclass MainApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        YorkieLogger.initLogger()\n    }\n}\n"}]}]}]}]}]},{"isFile":true,"isOpen":false,"language":"markup","name":"AndroidManifest.xml","path":"/src/main/AndroidManifest.xml","content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:name=\".MainApplication\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:networkSecurityConfig=\"@xml/network_security_config\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.SimultaneousCursors\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:screenOrientation=\"landscape\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n"}]}]},{"isFile":true,"isOpen":false,"language":"","name":".gitignore","path":"/.gitignore","content":"*.iml\n.gradle\n/.idea/caches\n/.idea/libraries\n/.idea/modules.xml\n/.idea/workspace.xml\n/.idea/navEditor.xml\n/.idea/assetWizardSettings.xml\n.DS_Store\n/build\n/captures\n.externalNativeBuild\n.cxx\nlocal.properties\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"build.gradle.kts","path":"/build.gradle.kts","content":"import dev.yorkie.dsl.implementation\n\nplugins {\n    alias(libs.plugins.yorkie.examples.android.application)\n    alias(libs.plugins.yorkie.examples.android.application.compose)\n}\n\nandroid {\n    namespace = \"dev.yorkie.example.simultaneouscursors\"\n\n    defaultConfig {\n        applicationId = \"dev.yorkie.example.simultaneouscursors\"\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n\n    buildTypes {\n        release {\n            isShrinkResources = true\n            isMinifyEnabled = true\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\",\n            )\n        }\n    }\n}\n\ndependencies {\n    implementation(projects.yorkie)\n    implementation(projects.examples.feature.enterDocumentKey)\n\n    // Core Android dependencies\n    implementation(libs.androidx.core)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.androidx.lifecycle.runtime)\n    implementation(libs.androidx.activity.compose)\n\n    // Compose BOM\n    implementation(libs.androidx.compose.material)\n    implementation(libs.androidx.compose.material.icons.extended)\n\n    // ViewModel\n    implementation(libs.androidx.lifecycle.viewmodel)\n\n    // Coroutines\n    implementation(libs.kotlinx.coroutines)\n\n    // Gson\n    implementation(libs.gson)\n\n    implementation(libs.timber)\n\n    // Debug\n    debugImplementation(libs.androidx.compose.ui.test.manifest)\n}\n"}]}