import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"rich-text-editor","path":"/","children":[{"isFile":false,"name":"src","path":"/src","children":[{"isFile":false,"name":"main","path":"/src/main","children":[{"isFile":false,"name":"java","path":"/src/main/java","children":[{"isFile":false,"name":"dev","path":"/src/main/java/dev","children":[{"isFile":false,"name":"yorkie","path":"/src/main/java/dev/yorkie","children":[{"isFile":false,"name":"example","path":"/src/main/java/dev/yorkie/example","children":[{"isFile":false,"name":"richtexteditor","path":"/src/main/java/dev/yorkie/example/richtexteditor","children":[{"isFile":false,"name":"ui","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui","children":[{"isFile":false,"name":"theme","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/theme","children":[{"isFile":true,"isOpen":false,"language":"kotlin","name":"Color.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/theme/Color.kt","content":"package dev.yorkie.example.richtexteditor.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\nval Purple200 = Color(0xFFBB86FC)\nval Purple500 = Color(0xFF6200EE)\nval Purple700 = Color(0xFF3700B3)\nval Teal200 = Color(0xFF03DAC5)\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"Theme.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/theme/Theme.kt","content":"package dev.yorkie.example.richtexteditor.ui.theme\n\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.darkColors\nimport androidx.compose.material.lightColors\nimport androidx.compose.runtime.Composable\n\nprivate val DarkColorPalette = darkColors(\n    primary = Purple200,\n    primaryVariant = Purple700,\n    secondary = Teal200,\n)\n\nprivate val LightColorPalette = lightColors(\n    primary = Purple500,\n    primaryVariant = Purple700,\n    secondary = Teal200,\n)\n\n@Composable\nfun RichTextEditorTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit,\n) {\n    val colors = if (darkTheme) {\n        DarkColorPalette\n    } else {\n        LightColorPalette\n    }\n\n    MaterialTheme(\n        colors = colors,\n        typography = Typography,\n        content = content,\n    )\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"Type.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/theme/Type.kt","content":"package dev.yorkie.example.richtexteditor.ui.theme\n\nimport androidx.compose.material.Typography\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.sp\n\nval Typography = Typography(\n    body1 = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp,\n    ),\n)\n"}]},{"isFile":false,"name":"richtexteditor","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor","children":[{"isFile":false,"name":"navigation","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor/navigation","children":[{"isFile":true,"isOpen":false,"language":"kotlin","name":"RichTextEditorNavigation.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor/navigation/RichTextEditorNavigation.kt","content":"package dev.yorkie.example.richtexteditor.ui.richtexteditor.navigation\n\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavController\nimport androidx.navigation.NavGraphBuilder\nimport androidx.navigation.NavType\nimport androidx.navigation.compose.composable\nimport androidx.navigation.navArgument\nimport dev.yorkie.example.richtexteditor.ui.richtexteditor.EditorViewModel\nimport dev.yorkie.example.richtexteditor.ui.richtexteditor.RichTextEditorScreen\nimport java.net.URLEncoder\nimport kotlin.text.Charsets.UTF_8\n\nconst val DOCUMENT_KEY_ARG = \"documentKey\"\nconst val RICH_TEXT_EDITOR_BASE_ROUTE = \"rich_text_editor_route\"\nconst val RICH_TEXT_EDITOR_ROUTE = \"rich_text_editor_route?$DOCUMENT_KEY_ARG={$DOCUMENT_KEY_ARG}\"\n\nfun NavController.navigateToRichTextEditor(documentKey: String) {\n    val encodedDocumentKey = URLEncoder.encode(documentKey, UTF_8.name())\n    val route = \"$RICH_TEXT_EDITOR_BASE_ROUTE?${DOCUMENT_KEY_ARG}=$encodedDocumentKey\"\n    navigate(route = route)\n}\n\nfun NavGraphBuilder.richTextEditorScreen() {\n    composable(\n        route = RICH_TEXT_EDITOR_ROUTE,\n        arguments = listOf(\n            navArgument(DOCUMENT_KEY_ARG) {\n                defaultValue = null\n                nullable = true\n                type = NavType.StringType\n            },\n        ),\n    ) { backStackEntry ->\n        val documentKey = backStackEntry.arguments?.getString(DOCUMENT_KEY_ARG)\n\n        val viewModel: EditorViewModel = viewModel(\n            factory = EditorViewModel.provideFactory(documentKey),\n        )\n\n        RichTextEditorScreen(\n            viewModel = viewModel,\n        )\n    }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"EditorViewModel.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor/EditorViewModel.kt","content":"package dev.yorkie.example.richtexteditor.ui.richtexteditor\n\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.text.input.TextFieldBuffer\nimport androidx.compose.foundation.text.input.TextFieldState\nimport androidx.compose.foundation.text.input.forEachChange\nimport androidx.compose.foundation.text.input.placeCursorAtEnd\nimport androidx.compose.runtime.snapshotFlow\nimport androidx.compose.ui.text.TextRange\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport com.google.gson.GsonBuilder\nimport com.google.gson.JsonDeserializationContext\nimport com.google.gson.JsonDeserializer\nimport com.google.gson.JsonElement\nimport com.google.gson.JsonPrimitive\nimport com.google.gson.JsonSerializationContext\nimport com.google.gson.JsonSerializer\nimport com.google.gson.reflect.TypeToken\nimport dev.yorkie.core.Client\nimport dev.yorkie.core.Client.SyncMode.Realtime\nimport dev.yorkie.core.Client.SyncMode.RealtimePushOnly\nimport dev.yorkie.document.Document\nimport dev.yorkie.document.Document.Event.PresenceChanged\nimport dev.yorkie.document.json.JsonText\nimport dev.yorkie.document.operation.OperationInfo\nimport dev.yorkie.document.time.ActorID\nimport dev.yorkie.example.richtexteditor.BuildConfig\nimport java.lang.reflect.Type\nimport java.net.URLDecoder\nimport kotlin.random.Random\nimport kotlin.text.Charsets.UTF_8\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.flow.filterIsInstance\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\n\ndata class EditorUiState(\n    val isLoading: Boolean = true,\n    val error: String? = null,\n    val peers: List<String> = emptyList(),\n    val selectionPeers: Map<ActorID, Selection?> = emptyMap(),\n    val styleOperations: List<OperationInfo.StyleOpInfo> = emptyList(),\n    val isBold: Boolean = false,\n    val isItalic: Boolean = false,\n    val isUnderline: Boolean = false,\n    val isStrikethrough: Boolean = false,\n)\n\ndata class Selection(\n    val name: String,\n    val from: Int,\n    val to: Int,\n    val color: String,\n)\n\n@OptIn(ExperimentalFoundationApi::class)\nclass EditorViewModel(\n    documentKey: String,\n) : ViewModel() {\n    private val client = Client(\n        options = Client.Options(\n            apiKey = BuildConfig.YORKIE_API_KEY,\n        ),\n        host = BuildConfig.YORKIE_SERVER_URL,\n    )\n\n    private val document = Document(documentKey)\n\n    private val _uiState = MutableStateFlow(EditorUiState())\n    val uiState = _uiState.asStateFlow()\n\n    val textFieldState = TextFieldState()\n\n    private var myClientId = ActorID(\"\")\n\n    private val gson = GsonBuilder()\n        .registerTypeAdapter(ActorID::class.java, ActorIDAdapter())\n        .create()\n\n    init {\n        viewModelScope.launch {\n            connectAndAttachDocument()\n        }\n\n        viewModelScope.launch {\n            launch {\n                document.events.collect { event ->\n                    when (event) {\n                        is Document.Event.Snapshot -> {\n                            syncTextSnapShot()\n                        }\n\n                        is Document.Event.LocalChange -> {\n                            // Only sync text, NOT selection (to avoid cursor jumping)\n                            val selectionPeers = document.presences.value.mapValues {\n                                it.value.mapToSelection(it.key)\n                            }\n                            _uiState.update {\n                                it.copy(\n                                    selectionPeers = selectionPeers,\n                                )\n                            }\n                        }\n\n                        is Document.Event.RemoteChange -> {\n                            // Sync both text and selection for remote changes\n                            syncTextRemoteChanged(event.changeInfo)\n                        }\n\n                        is PresenceChanged.Others.PresenceChanged -> {\n                            val actorID = event.changed.actorID\n                            val peerSelection = event.changed.presence.mapToSelection(actorID)\n                            val selectionPeers = _uiState.value.selectionPeers.toMutableMap()\n                            selectionPeers[actorID] = peerSelection\n                            _uiState.update {\n                                it.copy(\n                                    selectionPeers = selectionPeers,\n                                )\n                            }\n                        }\n\n                        is PresenceChanged.MyPresence.PresenceChanged -> {\n                            val newActorId = event.changed.actorID\n                            if (myClientId != newActorId) {\n                                myClientId = newActorId\n                            }\n                        }\n\n                        is PresenceChanged.Others.Unwatched -> {\n                            val unwatchedActorId = event.changed.actorID\n                            removeUnwatchedPeerSelectionInfo(unwatchedActorId)\n                        }\n\n                        is PresenceChanged.MyPresence.Initialized -> {\n                            val selectionPeers = document.presences.value.mapValues {\n                                it.value.mapToSelection(it.key)\n                            }\n                            _uiState.update {\n                                it.copy(\n                                    selectionPeers = selectionPeers,\n                                )\n                            }\n\n                            handleSelectEvent(\n                                textFieldState.selection.start,\n                                textFieldState.selection.end,\n                            )\n                        }\n\n                        else -> {}\n                    }\n                }\n            }\n\n            launch {\n                document.events.filterIsInstance<PresenceChanged>().collect {\n                    val peers = document.presences.value.values.map {\n                        gson.fromJson(it[\"username\"], String::class.java)\n                    }\n                    _uiState.update {\n                        it.copy(\n                            peers = peers,\n                        )\n                    }\n                }\n            }\n\n            launch {\n                snapshotFlow { textFieldState.selection }.collectLatest {\n                    handleSelectEvent(textFieldState.selection.start, textFieldState.selection.end)\n                }\n            }\n        }\n    }\n\n    private suspend fun connectAndAttachDocument() {\n        try {\n            val activateAsyncResult = client.activateAsync().await()\n            if (!activateAsyncResult.isSuccess) {\n                _uiState.value = _uiState.value.copy(\n                    isLoading = false,\n                    error = \"Failed to connect to Yorkie server\",\n                )\n                Timber.e(\n                    \"${this@EditorViewModel::class.java.name}#init: %s\",\n                    \"Failed to connect to Yorkie server ${BuildConfig.YORKIE_SERVER_URL}, \" +\n                        \"Error: ${activateAsyncResult.exceptionOrNull()}\",\n                )\n                return\n            }\n\n            val attachDocumentResult = client.attachDocument(\n                document,\n                initialPresence = mapOf(\n                    \"username\" to \"\\\"${generateDisplayName()}\\\"\",\n                    \"color\" to \"\\\"${randomColorString()}\\\"\",\n                ),\n            ).await()\n            if (!attachDocumentResult.isSuccess) {\n                _uiState.value = _uiState.value.copy(\n                    isLoading = false,\n                    error = \"Failed to attach document to Yorkie server\",\n                )\n                Timber.e(\n                    \"${this@EditorViewModel::class.java.name}#init: %s\",\n                    \"Failed to attach document ${document.getKey()} \" +\n                        \"to Yorkie server ${BuildConfig.YORKIE_SERVER_URL}, \" +\n                        \"Error: ${attachDocumentResult.exceptionOrNull()}\",\n                )\n                return\n            }\n\n            Timber.i(\n                \"${this@EditorViewModel::class.java.name}#init: %s\",\n                \"Connected to Yorkie server ${BuildConfig.YORKIE_SERVER_URL} \" +\n                    \"with document ${document.getKey()}\",\n            )\n\n            if (document.getRoot().getAsOrNull<JsonText>(CONTENT) == null) {\n                document.updateAsync { root, _ ->\n                    root.setNewText(CONTENT).apply {\n                        edit(0, 0, \"\\n\")\n                    }\n                }.await()\n            }\n\n            client.syncAsync().await()\n            _uiState.update { it.copy(isLoading = false) }\n        } catch (e: Exception) {\n            _uiState.update {\n                it.copy(\n                    isLoading = false,\n                    error = e.message ?: \"Unknown error occurred\",\n                )\n            }\n            Timber.e(\n                \"${this@EditorViewModel::class.java.name}#init: %s\",\n                e.message ?: \"Unknown error occurred\",\n            )\n        }\n    }\n\n    /**\n     * Syncs the text content snapshot from the Yorkie document to the UI state\n     */\n    private suspend fun syncTextSnapShot() {\n        val content = document.getRoot().getAsOrNull<JsonText>(CONTENT)\n        val newStyleOperations = ArrayList<OperationInfo.StyleOpInfo>()\n        var idx = 0\n        content?.values?.forEach { textWithAttributes ->\n            newStyleOperations.add(\n                OperationInfo.StyleOpInfo(\n                    from = idx,\n                    to = idx + textWithAttributes.text.length,\n                    attributes = textWithAttributes.attributes,\n                ),\n            )\n            idx += textWithAttributes.text.length\n        }\n        textFieldState.edit {\n            val newContent = content.toString().dropLineBreakLast()\n            replace(0, length, newContent)\n            placeCursorAtEnd()\n        }\n        _uiState.update {\n            it.copy(\n                styleOperations = newStyleOperations,\n            )\n        }\n    }\n\n    private suspend fun syncTextRemoteChanged(changeInfo: Document.Event.ChangeInfo) {\n        val content = document.getRoot().getAsOrNull<JsonText>(CONTENT)\n        val newStyleOperations = ArrayList<OperationInfo.StyleOpInfo>()\n        var idx = 0\n        content?.values?.forEach { textWithAttributes ->\n            newStyleOperations.add(\n                OperationInfo.StyleOpInfo(\n                    from = idx,\n                    to = idx + textWithAttributes.text.length,\n                    attributes = textWithAttributes.attributes,\n                ),\n            )\n            idx += textWithAttributes.text.length\n        }\n\n        // Adjust local text selection based on remote edits\n        val editOperations = changeInfo.operations\n            .filterIsInstance<OperationInfo.EditOpInfo>()\n        var currentFrom = textFieldState.selection.start\n        var currentTo = textFieldState.selection.end\n        for (editOpInfo in editOperations) {\n            val newSelection = calculateNewSelection(\n                currentFrom = currentFrom,\n                currentTo = currentTo,\n                editFrom = editOpInfo.from,\n                editTo = editOpInfo.to,\n                editValue = editOpInfo.value.text,\n            )\n            currentFrom = newSelection.first\n            currentTo = newSelection.second\n        }\n\n        textFieldState.edit {\n            replace(0, length, content.toString().dropLineBreakLast())\n            selection = TextRange(\n                start = currentFrom.coerceIn(0, length),\n                end = currentTo.coerceIn(0, length),\n            )\n        }\n\n        _uiState.update { state ->\n            state.copy(\n                styleOperations = newStyleOperations,\n                selectionPeers = document.presences.value.mapValues {\n                    it.value.mapToSelection(it.key)\n                },\n            )\n        }\n    }\n\n    private suspend fun Map<String, String>.mapToSelection(actorID: ActorID): Selection? {\n        if (actorID == myClientId) return null\n\n        // Deserialize to DTO first (ProGuard-safe with @SerializedName)\n        val jsonArray = gson.fromJson<List<RgaTreeSplitPosDto>>(\n            this[\"selection\"],\n            object : TypeToken<List<RgaTreeSplitPosDto>>() {}.type,\n        )\n        return try {\n            if (jsonArray != null && jsonArray.size >= 2) {\n                // Convert DTO to SDK struct\n                val fromPos = jsonArray[0].toRgaTreeSplitPosStruct()\n                val toPos = jsonArray[1].toRgaTreeSplitPosStruct()\n\n                val content = document.getRoot().getAsOrNull<JsonText>(CONTENT) ?: return null\n\n                val (from, to) = content.posRangeToIndexRange(fromPos to toPos)\n\n                // Validate indices against actual content length\n                val contentLength = content.toString().length\n                val validFrom = from.coerceIn(0, contentLength)\n                val validTo = to.coerceIn(0, contentLength)\n\n                Selection(\n                    name = gson.fromJson(this[\"username\"], String::class.java),\n                    from = validFrom,\n                    to = validTo,\n                    color = gson.fromJson(this[\"color\"], String::class.java),\n                )\n            } else {\n                null\n            }\n        } catch (e: Exception) {\n            null\n        }\n    }\n\n    fun editContent(changes: TextFieldBuffer.ChangeList, newContent: CharSequence) {\n        viewModelScope.launch {\n            document.updateAsync { root, _ ->\n                changes.forEachChange { range, originalRange ->\n                    val content = if (range.start == range.end) {\n                        \"\"\n                    } else {\n                        newContent.substring(range.start, range.end)\n                    }\n\n                    val styles = ArrayList<EditStyle>()\n                    if (content.isNotEmpty()) {\n                        if (_uiState.value.isBold) {\n                            styles.add(EditStyle.BOLD)\n                        }\n                        if (_uiState.value.isItalic) {\n                            styles.add(EditStyle.ITALIC)\n                        }\n                        if (_uiState.value.isUnderline) {\n                            styles.add(EditStyle.UNDERLINE)\n                        }\n                        if (_uiState.value.isStrikethrough) {\n                            styles.add(EditStyle.STRIKETHROUGH)\n                        }\n                    }\n\n                    root.getAs<JsonText>(CONTENT).edit(\n                        fromIndex = originalRange.start,\n                        toIndex = originalRange.end,\n                        content = content,\n                        attributes = styles.associate {\n                            it.key to \"true\"\n                        },\n                    )\n                }\n            }.await()\n            syncTextStyle()\n        }\n    }\n\n    private suspend fun syncTextStyle() {\n        val newStyleOperations = ArrayList<OperationInfo.StyleOpInfo>()\n        var idx = 0\n        val t = StringBuilder()\n        document.getRoot().getAsOrNull<JsonText>(CONTENT)?.values?.forEach { textWithAttributes ->\n            t.append(textWithAttributes.text)\n            newStyleOperations.add(\n                OperationInfo.StyleOpInfo(\n                    from = idx,\n                    to = idx + textWithAttributes.text.length,\n                    attributes = textWithAttributes.attributes,\n                ),\n            )\n            idx += textWithAttributes.text.length\n        }\n        _uiState.update {\n            it.copy(\n                styleOperations = newStyleOperations,\n            )\n        }\n    }\n\n    private fun handleSelectEvent(from: Int, to: Int) {\n        viewModelScope.launch {\n            // Update Yorkie presence\n            document.updateAsync { root, presence ->\n                val range = root.getAs<JsonText>(CONTENT)\n                    .indexRangeToPosRange(from to to)?.toList().orEmpty()\n                // Convert to DTO for ProGuard-safe serialization\n                val rangeDto = range.map { RgaTreeSplitPosDto.fromRgaTreeSplitPosStruct(it) }\n                presence.put(mapOf(\"selection\" to gson.toJson(rangeDto)))\n            }.await()\n        }\n    }\n\n    private fun toggleStyle(\n        style: EditStyle,\n        currentValue: Boolean,\n        updateState: (EditorUiState) -> EditorUiState,\n    ) {\n        _uiState.update(updateState)\n\n        val textSelection = textFieldState.selection\n        if (textSelection.start < textSelection.end) {\n            viewModelScope.launch {\n                document.updateAsync { root, _ ->\n                    root.getAs<JsonText>(CONTENT).style(\n                        fromIndex = textSelection.start,\n                        toIndex = textSelection.end,\n                        attributes = mapOf(\n                            style.key to if (!currentValue) \"true\" else \"null\",\n                        ),\n                    )\n                }.await()\n                syncTextStyle()\n            }\n        }\n    }\n\n    fun toggleBold() {\n        toggleStyle(\n            EditStyle.BOLD,\n            _uiState.value.isBold,\n        ) { it.copy(isBold = !it.isBold) }\n    }\n\n    fun toggleItalic() {\n        toggleStyle(\n            EditStyle.ITALIC,\n            _uiState.value.isItalic,\n        ) { it.copy(isItalic = !it.isItalic) }\n    }\n\n    fun toggleUnderline() {\n        toggleStyle(\n            EditStyle.UNDERLINE,\n            _uiState.value.isUnderline,\n        ) { it.copy(isUnderline = !it.isUnderline) }\n    }\n\n    fun toggleStrikethrough() {\n        toggleStyle(\n            EditStyle.STRIKETHROUGH,\n            _uiState.value.isStrikethrough,\n        ) { it.copy(isStrikethrough = !it.isStrikethrough) }\n    }\n\n    fun clearFormatting() {\n        _uiState.update {\n            it.copy(\n                isBold = false,\n                isItalic = false,\n                isUnderline = false,\n                isStrikethrough = false,\n            )\n        }\n    }\n\n    /**\n     * Calculates the new selection position after a remote edit\n     */\n    private fun calculateNewSelection(\n        currentFrom: Int,\n        currentTo: Int,\n        editFrom: Int,\n        editTo: Int,\n        editValue: String,\n    ): Pair<Int, Int> {\n        val deletedLength = editTo - editFrom\n        val insertedLength = editValue.length\n        val delta = insertedLength - deletedLength\n\n        return when {\n            // Selection is before the edit - no change needed\n            currentTo <= editFrom -> {\n                currentFrom to currentTo\n            }\n\n            // Selection starts after the edit - shift by delta\n            currentFrom >= editTo -> {\n                (currentFrom + delta) to (currentTo + delta)\n            }\n\n            // Selection overlaps with edit - collapse to end of edit\n            else -> {\n                val newPos = editFrom + insertedLength\n                newPos to newPos\n            }\n        }\n    }\n\n    /**\n     * Removes selection color info when a peer disconnects\n     */\n    private fun removeUnwatchedPeerSelectionInfo(actorID: ActorID) {\n        _uiState.update { currentState ->\n            val updatedSelections = currentState.selectionPeers.toMutableMap()\n            updatedSelections.remove(actorID)\n            currentState.copy(selectionPeers = updatedSelections)\n        }\n    }\n\n    /**\n     * Switches to push-only mode during Hangul composition to prevent conflicts\n     */\n    fun handleHangulCompositionStart() {\n        client.changeSyncMode(document, RealtimePushOnly)\n    }\n\n    /**\n     * Switches back to real-time mode after Hangul composition ends\n     */\n    fun handleHangulCompositionEnd() {\n        client.changeSyncMode(document, Realtime)\n    }\n\n    private fun randomColorString(): String {\n        val random = Random.Default\n        val color = (0xFFFFFF and random.nextInt()).toString(16).padStart(6, '0')\n        return \"#$color\"\n    }\n\n    /**\n     * Generates a user-friendly display name from a clientID.\n     * This creates a consistent name for each client based on their ID.\n     */\n    private fun generateDisplayName(): String {\n        // List of friendly adjectives and nouns for generating names\n        val adjectives = listOf(\n            \"Happy\", \"Swift\", \"Bright\", \"Cool\", \"Smart\", \"Quick\", \"Bold\", \"Calm\",\n            \"Wise\", \"Kind\", \"Brave\", \"Sharp\", \"Gentle\", \"Strong\", \"Clever\", \"Warm\",\n        )\n\n        val nouns = listOf(\n            \"Fox\", \"Eagle\", \"Tiger\", \"Wolf\", \"Bear\", \"Lion\", \"Hawk\", \"Owl\",\n            \"Deer\", \"Rabbit\", \"Dolphin\", \"Whale\", \"Shark\", \"Panda\", \"Koala\", \"Penguin\",\n        )\n\n        return \"${adjectives.random()} ${nouns.random()}\"\n    }\n\n    private fun String.dropLineBreakLast() = if (endsWith(\"\\n\")) {\n        dropLast(1)\n    } else {\n        this\n    }\n\n    override fun onCleared() {\n        TerminationScope.launch {\n            client.detachDocument(document).await()\n            client.deactivateAsync().await()\n        }\n        super.onCleared()\n    }\n\n    companion object {\n        private const val CONTENT = \"content\"\n\n        private val TerminationScope = CoroutineScope(Dispatchers.Main.immediate + SupervisorJob())\n\n        fun provideFactory(documentKey: String?): ViewModelProvider.Factory =\n            object : ViewModelProvider.Factory {\n                override fun <T : ViewModel> create(modelClass: Class<T>): T {\n                    documentKey ?: throw IllegalArgumentException(\"Document Key is not found\")\n                    val decodedDocumentKey = URLDecoder.decode(documentKey, UTF_8.name())\n                    return EditorViewModel(decodedDocumentKey) as T\n                }\n            }\n    }\n\n    internal enum class EditStyle(\n        val key: String,\n    ) {\n        BOLD(\"bold\"),\n        ITALIC(\"italic\"),\n        UNDERLINE(\"underline\"),\n        STRIKETHROUGH(\"strike\"),\n    }\n}\n\nprivate class ActorIDAdapter : JsonDeserializer<ActorID>, JsonSerializer<ActorID> {\n    override fun deserialize(\n        json: JsonElement,\n        typeOfT: Type,\n        context: JsonDeserializationContext,\n    ): ActorID {\n        return ActorID(json.asString) // map raw string into ActorID\n    }\n\n    override fun serialize(\n        src: ActorID,\n        typeOfSrc: Type,\n        context: JsonSerializationContext,\n    ): JsonElement {\n        return JsonPrimitive(src.value) // write back as string\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"RichTextEditor.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor/RichTextEditor.kt","content":"package dev.yorkie.example.richtexteditor.ui.richtexteditor\n\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.BasicTextField\nimport androidx.compose.foundation.text.input.InputTransformation\nimport androidx.compose.foundation.text.input.OutputTransformation\nimport androidx.compose.foundation.text.input.TextFieldBuffer\nimport androidx.compose.foundation.text.input.TextFieldState\nimport androidx.compose.material.Card\nimport androidx.compose.material.Icon\nimport androidx.compose.material.IconButton\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Text\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Clear\nimport androidx.compose.material.icons.filled.FormatBold\nimport androidx.compose.material.icons.filled.FormatItalic\nimport androidx.compose.material.icons.filled.FormatUnderlined\nimport androidx.compose.material.icons.filled.StrikethroughS\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableIntStateOf\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.layout.onGloballyPositioned\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.text.SpanStyle\nimport androidx.compose.ui.text.TextLayoutResult\nimport androidx.compose.ui.text.font.FontStyle\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextDecoration\nimport androidx.compose.ui.unit.Dp\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.core.graphics.toColorInt\nimport dev.yorkie.document.operation.OperationInfo\nimport dev.yorkie.document.time.ActorID\nimport kotlin.math.roundToInt\n\nclass CustomOutputTransformation : OutputTransformation {\n    var styleOperations: List<OperationInfo.StyleOpInfo> by mutableStateOf(emptyList())\n    var selectionPeers: Map<ActorID, Selection?> by mutableStateOf(emptyMap())\n\n    override fun TextFieldBuffer.transformOutput() {\n        if (styleOperations.isNotEmpty()) {\n            // Apply all style operations to the text\n            styleOperations.forEach {\n                val from = it.from\n                val to = if (it.from == it.to) {\n                    it.to + 1\n                } else {\n                    it.to\n                }\n\n                if (to in (from + 1)..length) {\n                    val attributes = it.attributes\n                    if (attributes[\"bold\"]?.toBoolean() == true) {\n                        addStyle(\n                            spanStyle = SpanStyle(\n                                fontWeight = FontWeight.Bold,\n                            ),\n                            start = from,\n                            end = to,\n                        )\n                    }\n\n                    if (attributes[\"italic\"]?.toBoolean() == true) {\n                        addStyle(\n                            spanStyle = SpanStyle(\n                                fontStyle = FontStyle.Italic,\n                            ),\n                            start = from,\n                            end = to,\n                        )\n                    }\n\n                    val textDecorations = ArrayList<TextDecoration>()\n                    if (attributes[\"underline\"]?.toBoolean() == true) {\n                        textDecorations.add(TextDecoration.Underline)\n                    }\n                    if (attributes[\"strike\"]?.toBoolean() == true) {\n                        textDecorations.add(TextDecoration.LineThrough)\n                    }\n\n                    addStyle(\n                        spanStyle = SpanStyle(\n                            textDecoration = TextDecoration.combine(textDecorations),\n                        ),\n                        start = from,\n                        end = to,\n                    )\n                }\n            }\n        }\n\n        // Apply background colors for each remote cursor position\n        selectionPeers.values.filterNotNull().forEach { selection ->\n            val start = selection.from.coerceIn(0, length)\n            val end = selection.to.coerceIn(0, length)\n\n            if (start < end) {\n                // Selection range - highlight the entire range\n                addStyle(\n                    spanStyle = SpanStyle(\n                        background = selection.color.toColor().copy(alpha = 0.3f),\n                    ),\n                    start = start,\n                    end = end,\n                )\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun RichTextEditor(\n    textFieldState: TextFieldState,\n    isBold: Boolean,\n    isItalic: Boolean,\n    isUnderline: Boolean,\n    isStrikethrough: Boolean,\n    styleOperations: List<OperationInfo.StyleOpInfo>,\n    selectionPeers: Map<ActorID, Selection?>,\n    onContentChanged: (TextFieldBuffer.ChangeList, CharSequence) -> Unit,\n    onToggleBold: () -> Unit,\n    onToggleItalic: () -> Unit,\n    onToggleUnderline: () -> Unit,\n    onToggleStrikethrough: () -> Unit,\n    onClearFormatting: () -> Unit,\n    modifier: Modifier = Modifier,\n) {\n    var textLayoutResult by remember { mutableStateOf<TextLayoutResult?>(null) }\n    val scrollState = rememberScrollState()\n\n    val inputTransformation = remember {\n        InputTransformation {\n            onContentChanged(changes, asCharSequence())\n        }\n    }\n\n    val outputTransformation = remember {\n        CustomOutputTransformation()\n    }\n\n    LaunchedEffect(styleOperations, selectionPeers) {\n        outputTransformation.styleOperations = styleOperations\n        outputTransformation.selectionPeers = selectionPeers\n    }\n\n    Column(\n        modifier = modifier,\n    ) {\n        // Toolbar\n        Card(\n            modifier = Modifier.fillMaxWidth(),\n            backgroundColor = MaterialTheme.colors.surface,\n        ) {\n            Row(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(8.dp),\n                horizontalArrangement = Arrangement.SpaceEvenly,\n            ) {\n                // Bold button\n                IconButton(\n                    onClick = onToggleBold,\n                    modifier = Modifier.background(\n                        if (isBold) MaterialTheme.colors.primary else Color.Transparent,\n                        RoundedCornerShape(4.dp),\n                    ),\n                ) {\n                    Icon(\n                        Icons.Default.FormatBold,\n                        contentDescription = \"Bold\",\n                        tint = if (isBold) {\n                            MaterialTheme.colors.onPrimary\n                        } else {\n                            MaterialTheme.colors.onSurface\n                        },\n                    )\n                }\n\n                // Italic button\n                IconButton(\n                    onClick = onToggleItalic,\n                    modifier = Modifier.background(\n                        if (isItalic) {\n                            MaterialTheme.colors.primary\n                        } else {\n                            Color.Transparent\n                        },\n                        RoundedCornerShape(4.dp),\n                    ),\n                ) {\n                    Icon(\n                        Icons.Default.FormatItalic,\n                        contentDescription = \"Italic\",\n                        tint = if (isItalic) {\n                            MaterialTheme.colors.onPrimary\n                        } else {\n                            MaterialTheme.colors.onSurface\n                        },\n                    )\n                }\n\n                // Underline button\n                IconButton(\n                    onClick = onToggleUnderline,\n                    modifier = Modifier.background(\n                        if (isUnderline) {\n                            MaterialTheme.colors.primary\n                        } else {\n                            Color.Transparent\n                        },\n                        RoundedCornerShape(4.dp),\n                    ),\n                ) {\n                    Icon(\n                        Icons.Default.FormatUnderlined,\n                        contentDescription = \"Underline\",\n                        tint = if (isUnderline) {\n                            MaterialTheme.colors.onPrimary\n                        } else {\n                            MaterialTheme.colors.onSurface\n                        },\n                    )\n                }\n\n                // Strikethrough button\n                IconButton(\n                    onClick = onToggleStrikethrough,\n                    modifier = Modifier.background(\n                        if (isStrikethrough) {\n                            MaterialTheme.colors.primary\n                        } else {\n                            Color.Transparent\n                        },\n                        RoundedCornerShape(4.dp),\n                    ),\n                ) {\n                    Icon(\n                        Icons.Default.StrikethroughS,\n                        contentDescription = \"Strikethrough\",\n                        tint = if (isStrikethrough) {\n                            MaterialTheme.colors.onPrimary\n                        } else {\n                            MaterialTheme.colors.onSurface\n                        },\n                    )\n                }\n\n                // Clear formatting button\n                IconButton(\n                    onClick = onClearFormatting,\n                ) {\n                    Icon(\n                        Icons.Default.Clear,\n                        contentDescription = \"Clear Formatting\",\n                        tint = MaterialTheme.colors.onSurface,\n                    )\n                }\n            }\n        }\n\n        Spacer(modifier = Modifier.height(8.dp))\n\n        // Text Editor with Remote Selections Display\n        Card(\n            modifier = Modifier.fillMaxWidth(),\n            backgroundColor = MaterialTheme.colors.surface,\n        ) {\n            Box {\n                // Text field with embedded remote cursor highlights\n                BasicTextField(\n                    state = textFieldState,\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .padding(16.dp)\n                        .height(300.dp)\n                        .background(Color.White, RoundedCornerShape(4.dp)),\n                    onTextLayout = {\n                        textLayoutResult = it.invoke()\n                    },\n                    inputTransformation = inputTransformation,\n                    outputTransformation = outputTransformation,\n                    scrollState = scrollState,\n                )\n\n                // Cursor overlay for remote cursors when from == to\n                if (textLayoutResult != null) {\n                    RemoteCursorOverlay(\n                        text = textFieldState.text.toString(),\n                        selectionPeers = selectionPeers,\n                        textLayoutResult = textLayoutResult!!,\n                        scrollOffsetY = scrollState.value.toFloat(),\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .height(300.dp)\n                            .padding(16.dp),\n                    )\n                }\n            }\n        }\n    }\n}\n\nprivate fun String.toColor(): Color {\n    return Color(this.toColorInt())\n}\n\n/**\n * Overlay component that shows remote cursors when from == to (cursor position)\n */\n@Composable\nprivate fun RemoteCursorOverlay(\n    text: String,\n    selectionPeers: Map<ActorID, Selection?>,\n    textLayoutResult: TextLayoutResult,\n    scrollOffsetY: Float,\n    modifier: Modifier = Modifier,\n) {\n    Box(modifier = modifier) {\n        // Show cursor indicators for remote users when they have a cursor position (from == to)\n        selectionPeers.values.filterNotNull().forEach { selection ->\n            if (selection.from == selection.to) {\n                // This is a cursor position, not a selection\n                val cursorPosition = selection.from.coerceIn(0, text.length)\n\n                // Calculate accurate cursor position using proper text measurement\n                calculateAccurateCursorPosition(\n                    cursorIndex = cursorPosition,\n                    textLayoutResult = textLayoutResult,\n                    scrollOffsetY = scrollOffsetY,\n                )?.let { cursorPositionInfo ->\n                    // Position the cursor indicator with name label\n                    // Cursor indicator\n                    Box(\n                        modifier = Modifier\n                            .size(width = 2.dp, height = cursorPositionInfo.height)\n                            .offset {\n                                IntOffset(cursorPositionInfo.left, cursorPositionInfo.top)\n                            }\n                            .background(\n                                color = selection.color.toColor(),\n                                shape = RoundedCornerShape(1.dp),\n                            ),\n                    )\n\n                    // Name label below cursor, centered horizontally\n                    var textWidth by remember { mutableIntStateOf(0) }\n                    Text(\n                        text = selection.name,\n                        modifier = Modifier\n                            .onGloballyPositioned { coordinates ->\n                                textWidth = coordinates.size.width\n                            }\n                            .offset {\n                                // Center the text horizontally relative to the cursor\n                                val centeredLeft = cursorPositionInfo.left - (textWidth / 2)\n                                IntOffset(\n                                    centeredLeft.coerceAtLeast(0),\n                                    cursorPositionInfo.bottom + 4,\n                                )\n                            }\n                            .background(\n                                color = selection.color.toColor().copy(alpha = 0.8f),\n                                shape = RoundedCornerShape(4.dp),\n                            )\n                            .padding(horizontal = 4.dp, vertical = 2.dp),\n                        style = MaterialTheme.typography.caption.copy(\n                            color = Color.White,\n                            fontSize = 10.sp,\n                        ),\n                    )\n                }\n            }\n        }\n    }\n}\n\n/**\n * Data class to hold cursor position information\n */\nprivate data class CursorPositionInfo(\n    val left: Int,\n    val top: Int,\n    val bottom: Int,\n    val height: Dp,\n)\n\n/**\n * Calculate cursor position using the simplest possible approach\n * Adjusts for scroll offset to keep cursors aligned with scrolled text\n */\n@Composable\nprivate fun calculateAccurateCursorPosition(\n    cursorIndex: Int,\n    textLayoutResult: TextLayoutResult,\n    scrollOffsetY: Float,\n): CursorPositionInfo? {\n    val density = LocalDensity.current\n\n    return try {\n        // Ensure index is within valid range\n        val validIndex = cursorIndex.coerceIn(0, textLayoutResult.layoutInput.text.length)\n        val cursorRect = textLayoutResult.getCursorRect(validIndex)\n\n        // Check for invalid cursor rect\n        if (cursorIndex != 0 && cursorRect.left == 0f && cursorRect.right == 0f) {\n            null\n        } else if (cursorRect.width == 0f && cursorRect.height == 0f) {\n            null\n        } else {\n            // Apply scroll offset to the cursor position\n            val adjustedTop = cursorRect.top - scrollOffsetY\n            val adjustedBottom = cursorRect.bottom - scrollOffsetY\n\n            CursorPositionInfo(\n                left = cursorRect.left.roundToInt(),\n                top = adjustedTop.roundToInt(),\n                bottom = adjustedBottom.roundToInt(),\n                height = with(density) { cursorRect.height.toDp() },\n            )\n        }\n    } catch (e: Exception) {\n        null\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"RichTextEditorScreen.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor/RichTextEditorScreen.kt","content":"package dev.yorkie.example.richtexteditor.ui.richtexteditor\n\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.text.input.TextFieldBuffer\nimport androidx.compose.foundation.text.input.TextFieldState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.Card\nimport androidx.compose.material.CircularProgressIndicator\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport dev.yorkie.document.operation.OperationInfo\nimport dev.yorkie.document.time.ActorID\n\n@Composable\nfun RichTextEditorScreen(modifier: Modifier = Modifier, viewModel: EditorViewModel) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    RichTextEditorScreen(\n        isLoading = uiState.isLoading,\n        error = uiState.error,\n        peers = uiState.peers,\n        selectionPeers = uiState.selectionPeers,\n        textFieldState = viewModel.textFieldState,\n        isBold = uiState.isBold,\n        isItalic = uiState.isItalic,\n        isUnderline = uiState.isUnderline,\n        isStrikethrough = uiState.isStrikethrough,\n        styleOperations = uiState.styleOperations,\n        onContentChanged = viewModel::editContent,\n        onToggleBold = viewModel::toggleBold,\n        onToggleItalic = viewModel::toggleItalic,\n        onToggleUnderline = viewModel::toggleUnderline,\n        onToggleStrikethrough = viewModel::toggleStrikethrough,\n        onClearFormatting = viewModel::clearFormatting,\n        modifier = modifier,\n    )\n}\n\n@Composable\nfun RichTextEditorScreen(\n    isLoading: Boolean,\n    error: String?,\n    textFieldState: TextFieldState,\n    isBold: Boolean,\n    isItalic: Boolean,\n    isUnderline: Boolean,\n    isStrikethrough: Boolean,\n    styleOperations: List<OperationInfo.StyleOpInfo>,\n    peers: List<String>,\n    selectionPeers: Map<ActorID, Selection?>,\n    onContentChanged: (TextFieldBuffer.ChangeList, CharSequence) -> Unit,\n    onToggleBold: () -> Unit,\n    onToggleItalic: () -> Unit,\n    onToggleUnderline: () -> Unit,\n    onToggleStrikethrough: () -> Unit,\n    onClearFormatting: () -> Unit,\n    modifier: Modifier = Modifier,\n) {\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp)\n            .verticalScroll(rememberScrollState()),\n    ) {\n        // Participants section with cursor positions\n        ParticipantsSection(\n            peers = peers,\n        )\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        when {\n            isLoading -> {\n                Box(\n                    modifier = Modifier.fillMaxWidth(),\n                    contentAlignment = Alignment.Center,\n                ) {\n                    Column(\n                        horizontalAlignment = Alignment.CenterHorizontally,\n                    ) {\n                        CircularProgressIndicator()\n                        Spacer(modifier = Modifier.height(8.dp))\n                        Text(\"Loading editor...\")\n                    }\n                }\n            }\n\n            error != null -> {\n                Card(\n                    modifier = Modifier.fillMaxWidth(),\n                    backgroundColor = MaterialTheme.colors.error,\n                ) {\n                    Text(\n                        text = \"Error: $error\",\n                        modifier = Modifier.padding(16.dp),\n                        color = MaterialTheme.colors.onError,\n                    )\n                }\n            }\n\n            else -> {\n                // Rich Text Editor\n                RichTextEditor(\n                    textFieldState = textFieldState,\n                    isBold = isBold,\n                    isItalic = isItalic,\n                    isUnderline = isUnderline,\n                    isStrikethrough = isStrikethrough,\n                    styleOperations = styleOperations,\n                    selectionPeers = selectionPeers,\n                    onContentChanged = onContentChanged,\n                    onToggleBold = onToggleBold,\n                    onToggleItalic = onToggleItalic,\n                    onToggleUnderline = onToggleUnderline,\n                    onToggleStrikethrough = onToggleStrikethrough,\n                    onClearFormatting = onClearFormatting,\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .height(400.dp),\n                )\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun ParticipantsSection(peers: List<String>, modifier: Modifier = Modifier) {\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        modifier = modifier,\n    ) {\n        Text(\n            text = \"Participants:\",\n            fontWeight = FontWeight.Bold,\n        )\n\n        Spacer(modifier = Modifier.width(8.dp))\n\n        Text(\n            text = \"[${peers.joinToString()}]\",\n        )\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"SelectionDto.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/richtexteditor/SelectionDto.kt","content":"package dev.yorkie.example.richtexteditor.ui.richtexteditor\n\nimport com.google.gson.annotations.SerializedName\nimport dev.yorkie.document.RgaTreeSplitNodeIDStruct\nimport dev.yorkie.document.RgaTreeSplitPosStruct\nimport dev.yorkie.document.TimeTicketStruct\nimport dev.yorkie.document.time.ActorID\n\n/**\n * DTO classes for JSON serialization with Gson.\n * These classes use @SerializedName to ensure ProGuard doesn't break deserialization.\n */\n\n/**\n * DTO representation of TimeTicket for JSON serialization\n */\ndata class TimeTicketDto(\n    @SerializedName(\"lamport\")\n    val lamport: String,\n    @SerializedName(\"delimiter\")\n    val delimiter: Int,\n    @SerializedName(\"actorID\")\n    val actorID: String,\n)\n\n/**\n * DTO representation of RgaTreeSplitNodeID for JSON serialization\n */\ndata class RgaTreeSplitNodeIdDto(\n    @SerializedName(\"createdAt\")\n    val createdAt: TimeTicketDto,\n    @SerializedName(\"offset\")\n    val offset: Int,\n)\n\n/**\n * DTO representation of RgaTreeSplitPos for JSON serialization\n */\ndata class RgaTreeSplitPosDto(\n    @SerializedName(\"id\")\n    val id: RgaTreeSplitNodeIdDto,\n    @SerializedName(\"relativeOffset\")\n    val relativeOffset: Int,\n) {\n    /**\n     * Converts this DTO to the SDK's RgaTreeSplitPosStruct\n     */\n    fun toRgaTreeSplitPosStruct(): RgaTreeSplitPosStruct {\n        return RgaTreeSplitPosStruct(\n            id = RgaTreeSplitNodeIDStruct(\n                createdAt = TimeTicketStruct(\n                    lamport = id.createdAt.lamport,\n                    delimiter = id.createdAt.delimiter.toUInt(),\n                    actorID = ActorID(id.createdAt.actorID),\n                ),\n                offset = id.offset,\n            ),\n            relativeOffset = relativeOffset,\n        )\n    }\n\n    companion object {\n        /**\n         * Creates a DTO from the SDK's RgaTreeSplitPosStruct\n         */\n        fun fromRgaTreeSplitPosStruct(struct: RgaTreeSplitPosStruct): RgaTreeSplitPosDto {\n            return RgaTreeSplitPosDto(\n                id = RgaTreeSplitNodeIdDto(\n                    createdAt = TimeTicketDto(\n                        lamport = struct.id.createdAt.lamport,\n                        delimiter = struct.id.createdAt.delimiter.toInt(),\n                        actorID = struct.id.createdAt.actorID.value,\n                    ),\n                    offset = struct.id.offset,\n                ),\n                relativeOffset = struct.relativeOffset,\n            )\n        }\n    }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"RichTextEditorAppHost.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/ui/RichTextEditorAppHost.kt","content":"package dev.yorkie.example.richtexteditor.ui\n\nimport androidx.compose.runtime.Composable\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport dev.yorkie.example.feature.enterdocumentkey.navigation.ENTER_DOCUMENT_KEY_ROUTE\nimport dev.yorkie.example.feature.enterdocumentkey.navigation.enterDocumentKeyScreen\nimport dev.yorkie.example.richtexteditor.ui.richtexteditor.navigation.navigateToRichTextEditor\nimport dev.yorkie.example.richtexteditor.ui.richtexteditor.navigation.richTextEditorScreen\n\n@Composable\nfun RichTextEditorAppHost(navController: NavHostController) {\n    NavHost(\n        navController = navController,\n        startDestination = ENTER_DOCUMENT_KEY_ROUTE,\n    ) {\n        enterDocumentKeyScreen(\n            onNextClick = {\n                navController.navigateToRichTextEditor(it)\n            },\n        )\n\n        richTextEditorScreen()\n    }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"MainActivity.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/MainActivity.kt","content":"package dev.yorkie.example.richtexteditor\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.navigationBarsPadding\nimport androidx.compose.foundation.layout.statusBarsPadding\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.ui.Modifier\nimport androidx.navigation.compose.rememberNavController\nimport dev.yorkie.example.richtexteditor.ui.RichTextEditorAppHost\nimport dev.yorkie.example.richtexteditor.ui.theme.RichTextEditorTheme\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            RichTextEditorTheme {\n                Surface(\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .statusBarsPadding()\n                        .navigationBarsPadding(),\n                    color = MaterialTheme.colors.background,\n                ) {\n                    RichTextEditorAppHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"kotlin","name":"MainApplication.kt","path":"/src/main/java/dev/yorkie/example/richtexteditor/MainApplication.kt","content":"package dev.yorkie.example.richtexteditor\n\nimport android.app.Application\nimport dev.yorkie.example.core.common.logger.YorkieLogger\n\nclass MainApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        YorkieLogger.initLogger()\n    }\n}\n"}]}]}]}]}]},{"isFile":true,"isOpen":false,"language":"markup","name":"AndroidManifest.xml","path":"/src/main/AndroidManifest.xml","content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <application\n        android:name=\".MainApplication\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:networkSecurityConfig=\"@xml/network_security_config\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.YorkieAndroidSDK\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n"}]}]},{"isFile":true,"isOpen":false,"language":"kotlin","name":"build.gradle.kts","path":"/build.gradle.kts","content":"import dev.yorkie.dsl.implementation\n\nplugins {\n    alias(libs.plugins.yorkie.examples.android.application)\n    alias(libs.plugins.yorkie.examples.android.application.compose)\n}\n\nandroid {\n    namespace = \"dev.yorkie.example.richtexteditor\"\n\n    defaultConfig {\n        applicationId = \"dev.yorkie.example.richtexteditor\"\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n\n    buildTypes {\n        release {\n            isShrinkResources = true\n            isMinifyEnabled = true\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\",\n            )\n        }\n    }\n}\n\ndependencies {\n    implementation(projects.yorkie)\n    implementation(projects.examples.feature.enterDocumentKey)\n\n    implementation(libs.androidx.core)\n    implementation(libs.androidx.lifecycle.runtime)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.compose.material)\n    implementation(libs.androidx.compose.material.icons.extended)\n    implementation(libs.androidx.lifecycle.viewmodel)\n    implementation(libs.material)\n    implementation(libs.gson)\n    implementation(libs.timber)\n}\n"}]}