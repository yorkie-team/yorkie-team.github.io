import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"SimultaneousCursors","path":"/","children":[{"isFile":false,"name":"SimultaneousCursors.xcodeproj","path":"/SimultaneousCursors.xcodeproj","children":[{"isFile":false,"name":"project.xcworkspace","path":"/SimultaneousCursors.xcodeproj/project.xcworkspace","children":[{"isFile":false,"name":"xcshareddata","path":"/SimultaneousCursors.xcodeproj/project.xcworkspace/xcshareddata","children":[{"isFile":true,"isOpen":false,"language":"markup","name":"IDEWorkspaceChecks.plist","path":"/SimultaneousCursors.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist","content":""}]},{"isFile":true,"isOpen":false,"language":"xcworkspacedata","name":"contents.xcworkspacedata","path":"/SimultaneousCursors.xcodeproj/project.xcworkspace/contents.xcworkspacedata","content":""}]},{"isFile":true,"isOpen":false,"language":"properties","name":"project.pbxproj","path":"/SimultaneousCursors.xcodeproj/project.pbxproj","content":""}]},{"isFile":false,"name":"SimultaneousCursors","path":"/SimultaneousCursors","children":[{"isFile":true,"isOpen":false,"language":"swift","name":"Constant.swift","path":"/SimultaneousCursors/Constant.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Foundation\n\nenum Constant {\n    private static var currentYorkieServerIP: String {\n        if let url = Bundle.main.url(forResource: \"BuildInfo\", withExtension: \"plist\"),\n           let data = try? Data(contentsOf: url),\n           let dict = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) as? [String: Any],\n           let ip = dict[\"CurrentIPAddress\"] as? String,\n           ip != \"0.0.0.0\"\n        {\n            return \"http://\\(ip):8080\"\n        }\n        return \"http://localhost:8080\"\n    }\n\n    static var serverAddress = currentYorkieServerIP\n    static var documentKey: String = \"simultaneous-cursors\"\n}\n\nenum TDError: Error {\n    case cannotInitClient(String)\n}\n\nenum ContentState {\n    case loading\n    case error(TDError)\n    case success\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentView.swift","path":"/SimultaneousCursors/ContentView.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\nstruct LineShape: Shape {\n    var points: [CGPoint]\n\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        guard self.points.count > 1 else { return path }\n\n        path.move(to: self.points[0])\n        for point in self.points.dropFirst() {\n            path.addLine(to: point)\n        }\n        return path\n    }\n}\n\nstruct LineDrawingView: View {\n    let positions: [CGPoint]\n    var body: some View {\n        LineShape(points: self.positions)\n            .stroke(Color.black, lineWidth: 3)\n    }\n}\n\nstruct ContentView: View {\n    let name: String\n    @State var viewModel = ContentViewModel()\n    @State private var dragOffset: CGSize = .zero\n    @State var currentPosition = CGPoint(x: 0, y: 0)\n    @State var isTouchDown = false\n\n    init(name: String) {\n        self.name = name\n    }\n\n    var body: some View {\n        ZStack {\n            Color.white.opacity(0.1)\n                .onTapGesture { location in\n                    self.viewModel.currentTimer?.invalidate()\n                    self.viewModel.currentTimer = nil\n\n                    let isTouchDownInsideX = location.x > self.currentPosition.x - 40 && location.x < self.currentPosition.x + 40\n                    let isTouchDownInsideY = location.y > self.currentPosition.y - 40 && location.y < self.currentPosition.y + 40\n                    self.isTouchDown = true\n                    self.changePosition(location, isTouchDown: isTouchDownInsideX && isTouchDownInsideY)\n                    if isTouchDownInsideX && isTouchDownInsideY {\n                        self.viewModel.currentTimer = Timer.scheduledTimer(withTimeInterval: 3, repeats: false) { _ in\n                            self.changePosition(location, isTouchDown: false)\n                        }\n                    }\n                    self.currentPosition = location\n                }\n                .gesture(self.dragGesture)\n            self.canvasView\n            self.menuView\n\n            VStack {\n                Text(self.name)\n                    .foregroundStyle(Color.white)\n                    .padding(3)\n                    .background(Color.red)\n                    .cornerRadius(2)\n                Image(systemName: self.viewModel.currentCursor.systemImageName)\n                    .foregroundStyle(\n                        Color(\n                            uiColor: .init(\n                                red: self.viewModel.currentCursor.color.r,\n                                green: self.viewModel.currentCursor.color.g,\n                                blue: self.viewModel.currentCursor.color.b,\n                                alpha: 1\n                            )\n                        )\n                    )\n            }\n            .position(self.viewModel.currentCursor == .pen ? .init(x: self.currentPosition.x + 20, y: self.currentPosition.y - 20) : self.currentPosition)\n            .overlay {\n                if self.isTouchDown, self.viewModel.currentCursor != .cursor, self.viewModel.currentCursor != .pen {\n                    AnimationView(\n                        shape: self.viewModel.currentCursor,\n                        position: .init(\n                            x: self.currentPosition.x,\n                            y: self.currentPosition.y\n                        )\n                    )\n                }\n            }\n\n            ForEach(self.viewModel.drawingNames, id: \\.self) { name in\n                let drawingPath = self.viewModel.paths[name] ?? []\n                LineDrawingView(positions: drawingPath)\n            }\n        }\n        .ignoresSafeArea()\n        .task {\n            await self.viewModel.initializeClient(with: self.name)\n        }\n        .onDisappear {\n            Task {\n                await self.viewModel.deactivate()\n            }\n        }\n    }\n\n    private var loadingView: some View {\n        ProgressView()\n    }\n\n    private func errorView(_ error: TDError) -> some View {\n        Text(\"Error occur: \\(error.localizedDescription)\")\n    }\n\n    var canvasView: some View {\n        Group {\n            ForEach(self.viewModel.uiPresenecs) { peer in\n                VStack {\n                    Text(peer.presence.name)\n                        .foregroundStyle(Color.white)\n                        .padding(3)\n                        .background(Color.red)\n                        .cornerRadius(2)\n                    Image(systemName: peer.presence.cursorShape.systemImageName)\n                        .resizable()\n                        .scaledToFit()\n                        .foregroundStyle(\n                            Color(\n                                uiColor: .init(\n                                    red: peer.presence.cursorShape.color.r,\n                                    green: peer.presence.cursorShape.color.g,\n                                    blue: peer.presence.cursorShape.color.b,\n                                    alpha: 1\n                                )\n                            )\n                        )\n                        .frame(width: 20, height: 20)\n                }\n                .position(\n                    x: peer.presence.cursor.xPos + (peer.presence.cursorShape == .pen ? 20 : 0),\n                    y: peer.presence.cursor.yPos + (peer.presence.cursorShape == .pen ? -20 : 0)\n                )\n                .overlay {\n                    if peer.presence.pointerDown, peer.presence.cursorShape != .cursor, peer.presence.cursorShape != .pen {\n                        AnimationView(\n                            shape: peer.presence.cursorShape,\n                            position: .init(\n                                x: peer.presence.cursor.xPos,\n                                y: peer.presence.cursor.yPos\n                            )\n                        )\n                    }\n                }\n            }\n        }\n    }\n\n    var dragGesture: some Gesture {\n        DragGesture()\n            .onChanged { value in\n                self.dragOffset = value.translation\n                self.currentPosition = value.location\n                self.changePosition(self.currentPosition, isTouchDown: self.viewModel.currentCursor == .pen)\n            }\n            .onEnded { _ in\n                withAnimation(.bouncy) {\n                    self.dragOffset = .zero\n                }\n                self.isTouchDown = false\n                self.changePosition(self.currentPosition, isTouchDown: false)\n            }\n    }\n\n    var menuView: some View {\n        VStack {\n            Spacer()\n\n            HStack {\n                Group {\n                    Button {\n                        self.viewModel.currentCursor = .heart\n                    } label: {\n                        Image(systemName: CursorShape.heart.systemImageName)\n                            .resizable()\n                            .scaledToFit()\n                            .foregroundStyle(Color.red)\n                            .background(Color.white)\n                    }\n                    Button {\n                        self.viewModel.currentCursor = .thumbs\n                    } label: {\n                        Image(systemName: CursorShape.thumbs.systemImageName)\n                            .resizable()\n                            .scaledToFit()\n                            .foregroundStyle(Color.yellow)\n                            .background(Color.white)\n                    }\n\n                    Button {\n                        self.viewModel.currentCursor = .pen\n                    } label: {\n                        Image(systemName: CursorShape.pen.systemImageName)\n                            .resizable()\n                            .scaledToFit()\n                            .foregroundStyle(Color.black)\n                            .background(Color.white)\n                    }\n\n                    Button {\n                        self.viewModel.currentCursor = .cursor\n                    } label: {\n                        Image(systemName: CursorShape.cursor.systemImageName)\n                            .resizable()\n                            .scaledToFit()\n                            .foregroundStyle(Color.black)\n                            .background(Color.white)\n                    }\n                }\n                .frame(width: 28, height: 28)\n                .padding(12)\n                .background(\n                    RoundedRectangle(cornerRadius: 12)\n                        .stroke(Color.red, lineWidth: 2)\n                )\n            }\n\n            Text(\"\\(self.viewModel.uiPresenecs.count) users here!\")\n        }\n    }\n\n    func changePosition(_ position: CGPoint, isTouchDown: Bool) {\n        self.viewModel.updatePosition(position, isTouchDown: isTouchDown)\n    }\n}\n\nstruct HeartView: View {\n    let shape: CursorShape\n    let position: CGPoint\n    init(shape: CursorShape, position: CGPoint) {\n        self.shape = shape\n        self.position = position\n    }\n\n    @State var offsetY: CGFloat = 0\n    @State var opacity: CGFloat = 1\n    var body: some View {\n        Image(systemName: self.shape.systemImageName)\n            .resizable()\n            .scaledToFit()\n            .foregroundStyle(Color(uiColor: .init(red: self.shape.color.r, green: self.shape.color.g, blue: self.shape.color.b, alpha: 1)))\n            .frame(width: 20, height: 20)\n            .opacity(self.opacity)\n            .position(x: self.position.x, y: self.position.y + self.offsetY)\n            .onAppear {\n                withAnimation(.easeOut(duration: 5)) {\n                    self.offsetY = -100\n                    self.opacity = 0\n                }\n            }\n    }\n}\n\nstruct AnimationView: View {\n    let shape: CursorShape\n    let position: CGPoint\n    @State var timer: Timer?\n\n    @State private var hearts: [UUID] = []\n    var body: some View {\n        VStack {\n            ZStack {\n                ForEach(self.hearts, id: \\.self) { _ in\n                    HeartView(shape: self.shape, position: .init(x: self.position.x + .random(in: 0 ... 20), y: self.position.y + .random(in: 0 ... 20)))\n                }\n            }\n        }\n        .onAppear {\n            Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in\n                if self.hearts.count <= 10 {\n                    withAnimation {\n                        self.hearts.append(.init())\n                    }\n                }\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentViewModel.swift","path":"/SimultaneousCursors/ContentViewModel.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Combine\nimport Foundation\nimport SwiftUI\nimport Yorkie\n\n@Observable\nclass ContentViewModel {\n    @ObservationIgnored var currentTimer: Timer?\n    let width = UIScreen.current!.bounds.size.width\n    let height = UIScreen.current!.bounds.size.height\n\n    @ObservationIgnored private var client: Client\n    @ObservationIgnored private let document: Document\n    @ObservationIgnored var presenecs = [Presence]()\n    var paths: [String: [CGPoint]] = [:]\n    var drawingNames: [String] = []\n\n    var uiPresenecs = [Model]()\n    var currentCursor: CursorShape = .heart {\n        didSet {\n            self.updateCursor()\n        }\n    }\n\n    private(set) var state = ContentState.loading\n\n    init() {\n        self.client = Client(Constant.serverAddress)\n        self.document = Document(key: Constant.documentKey)\n    }\n\n    func initializeClient(with name: String) async {\n        self.state = .loading\n        do {\n            try await self.client.activate()\n\n            let doc = try await client.attach(self.document, [\n                \"name\": name,\n                \"cursorShape\": \"heart\",\n                \"cursor\": [\"xPos\": 0.5, \"yPos\": 0.5],\n                \"pointerDown\": false\n            ])\n            try self.document.update { root, _ in\n                var text = root.content as? JSONText\n                if text == nil {\n                    root.content = JSONText()\n                    text = root.content as? JSONText\n                }\n            }\n            let pres = doc.getPresences()\n            self.mapFromPrecenscToUI(pres)\n            self.state = .success\n\n            await self.watch()\n        } catch {\n            self.state = .error(.cannotInitClient(\"\\(error.localizedDescription)\"))\n        }\n    }\n\n    func deactivate() async {\n        do {\n            try await self.client.deactivate()\n        } catch {}\n    }\n\n    func watch() async {\n        self.document.subscribe { [weak self] event, document in\n            if case .syncStatusChanged = event.type {\n                let presences = document.getPresences()\n                self?.mapFromPrecenscToUI(presences)\n            } else if case .presenceChanged = event.type {\n                let presences = document.getPresences()\n                self?.mapFromPrecenscToUI(presences)\n            }\n        }\n    }\n\n    @MainActor\n    private func mapFromPrecenscToUI(_ peers: [PeerElement]) {\n        var _uiPresenecs = [Model]()\n\n        for peer in peers {\n            let id = peer.clientID\n            let presentModel = peer.presence\n            let name = presentModel[\"name\"] as? String ?? \"anonymous\"\n            let pointerDown = presentModel[\"pointerDown\"] as? Bool\n            let cursor = presentModel[\"cursor\"] as? [String: Double]\n            let cursorShape = presentModel[\"cursorShape\"] as? String\n\n            guard let pointerDown, let cursor, let cursorShape, let cursorShape = CursorShape(rawValue: cursorShape) else {\n                continue\n            }\n\n            guard let xPos = cursor[\"xPos\"], let yPos = cursor[\"yPos\"] else { fatalError() }\n            let realxPos = xPos * self.width\n            let realyPos = yPos * self.height\n\n            let model = Model(\n                clientID: id,\n                presence: .init(\n                    name: name,\n                    pointerDown: pointerDown,\n                    cursorShape: cursorShape,\n                    cursor: .init(xPos: realxPos, yPos: realyPos)\n                )\n            )\n\n            if cursorShape == .pen, pointerDown {\n                self.drawingNames.append(name)\n                self.paths[name]?.append(.init(x: realxPos, y: realyPos))\n            } else {\n                self.drawingNames.removeAll(where: { $0 == name })\n                self.paths[name] = []\n            }\n\n            _uiPresenecs.append(model)\n        }\n\n        self.uiPresenecs.removeAll()\n        self.uiPresenecs = _uiPresenecs\n    }\n\n    func updatePosition(_ position: CGPoint, isTouchDown: Bool) {\n        do {\n            try self.document.update { _, presence in\n                presence.set([\n                    \"cursor\": [\"xPos\": position.x / self.width, \"yPos\": position.y / self.height],\n                    \"pointerDown\": isTouchDown\n                ])\n            }\n        } catch {\n            self.state = .error(.cannotInitClient(\"\\(error.localizedDescription)\"))\n        }\n    }\n\n    func updateCursor() {\n        do {\n            try self.document.update { _, presence in\n                presence.set([\"cursorShape\": self.currentCursor])\n            }\n        } catch {\n            self.state = .error(.cannotInitClient(\"\\(error.localizedDescription)\"))\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"PresenceModel.swift","path":"/SimultaneousCursors/PresenceModel.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Foundation\n\nstruct Cursor: Codable {\n    let xPos: Double\n    let yPos: Double\n}\n\nstruct PresenceModel: Codable {\n    let name: String\n    let pointerDown: Bool\n    let cursorShape: CursorShape\n    let cursor: Cursor\n}\n\nenum CursorShape: String, Codable {\n    case heart\n    case thumbs\n    case pen\n    case cursor\n\n    var systemImageName: String {\n        switch self {\n        case .heart: return \"heart.fill\"\n        case .thumbs: return \"hand.thumbsup.fill\"\n        case .pen: return \"paintbrush.pointed.fill\"\n        case .cursor: return \"cursorarrow\"\n        }\n    }\n\n    var color: ColorModel {\n        switch self {\n        case .heart:\n            return .init(r: 1, g: 0, b: 0, a: 1)\n        case .thumbs:\n            return .init(r: 1, g: 1, b: 0, a: 1)\n        case .pen:\n            return .init(r: 0, g: 0, b: 0, a: 1)\n        case .cursor:\n            return .init(r: 0, g: 0, b: 0, a: 0)\n        }\n    }\n}\n\nstruct Model: Codable, Identifiable {\n    var id: String { self.clientID }\n\n    let clientID: String\n    let presence: PresenceModel\n}\n\nstruct ColorModel {\n    let r, g, b, a: CGFloat\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"SimultaneousCursorsApp.swift","path":"/SimultaneousCursors/SimultaneousCursorsApp.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\n@main\nstruct SimultaneousCursorsApp: App {\n    @State var path = NavigationPath()\n    @State var name = \"\"\n    var body: some Scene {\n        WindowGroup {\n            NavigationStack(path: self.$path) {\n                ContentView(name: \"iOS\")\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"UIWindow+Ex.swift","path":"/SimultaneousCursors/UIWindow+Ex.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport UIKit\n\nextension UIWindow {\n    static var current: UIWindow? {\n        for scene in UIApplication.shared.connectedScenes {\n            guard let windowScene = scene as? UIWindowScene else { continue }\n            for window in windowScene.windows {\n                if window.isKeyWindow { return window }\n            }\n        }\n        return nil\n    }\n}\n\nextension UIScreen {\n    static var current: UIScreen? {\n        UIWindow.current?.screen\n    }\n}\n"}]}]}