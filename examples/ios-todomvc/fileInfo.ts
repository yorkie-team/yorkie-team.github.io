import { DirectoryInfo } from '@/utils/exampleFileUtils';
        export const FILE_INFO: DirectoryInfo = {"isFile":false,"name":"Todomvc","path":"/","children":[{"isFile":false,"name":"Todomvc.xcodeproj","path":"/Todomvc.xcodeproj","children":[{"isFile":false,"name":"project.xcworkspace","path":"/Todomvc.xcodeproj/project.xcworkspace","children":[{"isFile":false,"name":"xcshareddata","path":"/Todomvc.xcodeproj/project.xcworkspace/xcshareddata","children":[{"isFile":true,"isOpen":false,"language":"markup","name":"IDEWorkspaceChecks.plist","path":"/Todomvc.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist","content":""}]},{"isFile":true,"isOpen":false,"language":"xcworkspacedata","name":"contents.xcworkspacedata","path":"/Todomvc.xcodeproj/project.xcworkspace/contents.xcworkspacedata","content":""}]},{"isFile":true,"isOpen":false,"language":"properties","name":"project.pbxproj","path":"/Todomvc.xcodeproj/project.pbxproj","content":""}]},{"isFile":false,"name":"TODO","path":"/TODO","children":[{"isFile":false,"name":"Models","path":"/TODO/Models","children":[{"isFile":true,"isOpen":false,"language":"swift","name":"Constant.swift","path":"/TODO/Models/Constant.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\n\nenum Constant {\n    private static var currentYorkieServerIP: String {\n        if let url = Bundle.main.url(forResource: \"BuildInfo\", withExtension: \"plist\"),\n           let data = try? Data(contentsOf: url),\n           let dict = try? PropertyListSerialization.propertyList(from: data, options: [], format: nil) as? [String: Any],\n           let ip = dict[\"CurrentIPAddress\"] as? String,\n           ip != \"0.0.0.0\"\n        {\n            return \"http://\\(ip):8080\"\n        }\n        return \"http://localhost:8080\"\n    }\n\n    static var serverAddress = currentYorkieServerIP\n    static let apiKey = \"\"\n    static var documentKey: String = {\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateFormat = \"yyyyMMdd\"\n        dateFormatter.locale = Locale.current\n        let dateString = dateFormatter.string(from: Date())\n        var key = \"react-todomvc-\\(dateString)\"\n        return key\n    }()\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"TDError.swift","path":"/TODO/Models/TDError.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\n\nenum TDError: Error {\n    case cannotInitClient(String)\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"TodoModel.swift","path":"/TODO/Models/TodoModel.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Combine\nimport Foundation\nimport Yorkie\n\nstruct TodoModel: Identifiable, Equatable, JSONObjectable {\n    let completed: Bool\n    let id: String\n    let text: String\n}\n\nextension TodoModel {\n    static func makeTodo(with taskName: String) -> Self {\n        .init(completed: false, id: UUID().uuidString, text: taskName)\n    }\n}\n"}]},{"isFile":false,"name":"Assets.xcassets","path":"/TODO/Assets.xcassets","children":[{"isFile":false,"name":"AppIcon.appiconset","path":"/TODO/Assets.xcassets/AppIcon.appiconset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/TODO/Assets.xcassets/AppIcon.appiconset/Contents.json","content":"{\n  \"images\" : [\n    {\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"dark\"\n        }\n      ],\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"tinted\"\n        }\n      ],\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"16x16\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"16x16\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"32x32\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"32x32\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"128x128\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"128x128\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"256x256\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"256x256\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"512x512\"\n    },\n    {\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"512x512\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":false,"name":"AccentColor.colorset","path":"/TODO/Assets.xcassets/AccentColor.colorset","children":[{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/TODO/Assets.xcassets/AccentColor.colorset/Contents.json","content":"{\n  \"colors\" : [\n    {\n      \"idiom\" : \"universal\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"json","name":"Contents.json","path":"/TODO/Assets.xcassets/Contents.json","content":"{\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n"}]},{"isFile":true,"isOpen":false,"language":"markup","name":"BuildInfo.plist","path":"/TODO/BuildInfo.plist","content":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CurrentIPAddress</key>\n\t<string>192.168.100.149</string>\n</dict>\n</plist>\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentView.swift","path":"/TODO/ContentView.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\nstruct ContentView: View {\n    enum Status: String, Identifiable {\n        var id: String { rawValue }\n\n        case all = \"All\"\n        case active = \"Active\"\n        case completed = \"Completed\"\n    }\n\n    @StateObject private var viewModel = ContentViewModel()\n    @State private var selectedStatus = Status.all\n    @State private var showAdding = false\n    @State private var showEditing = false\n    @State private var selectedAll = false\n    @State private var newTaskName = \"\"\n    @State private var updatingModel: TodoModel? = nil\n    @State var showSetting = false\n    @State var key = \"\"\n    @Environment(\\.scenePhase) var scenePhase\n\n    private let status: [Status] = [.all, .active, .completed]\n    var body: some View {\n        Group {\n            switch self.viewModel.state {\n            case .error(let error):\n                errorView(error)\n            case .loading:\n                loadingView\n            case .success:\n                content\n            }\n        }\n        .onChange(of: self.scenePhase) { newPhase in\n            if newPhase == .active {\n                self.viewModel.refreshDocument()\n            }\n        }\n        .task {\n            await self.viewModel.initializeClient()\n        }\n        .sheet(isPresented: self.$showSetting) {\n            VStack {\n                HStack {\n                    Spacer()\n                    Button {\n                        self.showSetting = false\n                    } label: {\n                        Image(systemName: \"xmark\")\n                            .resizable()\n                            .scaledToFit()\n                            .frame(width: 30, height: 30)\n                    }\n                }\n                TextField(text: self.$key) {\n                    Text(\"Input new key\")\n                }\n\n                Button {\n                    self.showSetting = false\n                    self.viewModel.updateKeys(self.key)\n                } label: {\n                    Text(\"DONE\")\n                }\n\n                Spacer()\n            }\n            .padding()\n        }\n    }\n}\n\n// MARK: - Views\n\nextension ContentView {\n    private var content: some View {\n        VStack {\n            self.headerView\n\n            Spacer()\n\n            ScrollView {\n                let filteredModels: [TodoModel] = {\n                    switch self.selectedStatus {\n                    case .all:\n                        return self.viewModel.models\n                    case .active:\n                        return self.viewModel.models.filter { !$0.completed }\n                    case .completed:\n                        return self.viewModel.models.filter { $0.completed }\n                    }\n                }()\n                ForEach(filteredModels) { model in\n                    HStack(spacing: 20) {\n                        Button {\n                            Log.log(\"[UI] -> task complete -> model.id: \\(model.id), complete: \\(!model.completed)\", level: .info)\n                            complete(model.id, complete: !model.completed)\n                        } label: {\n                            Image(systemName: model.completed ? \"checkmark.circle\" : \"circle\")\n                                .resizable()\n                                .scaledToFit()\n                                .frame(width: 25, height: 25, alignment: .center)\n                        }\n\n                        Button {\n                            self.updatingModel = model\n                            self.showEditing = true\n                            self.newTaskName = model.text\n                        } label: {\n                            Text(\"\\(model.text)\")\n                                .strikethrough(model.completed)\n                                .multilineTextAlignment(.leading)\n                        }\n\n                        Spacer()\n                        Button {\n                            Log.log(\"[UI] -> delete task -> model.id: \\(model.id)\", level: .info)\n                            self.viewModel.deleteItem(model.id)\n                        } label: {\n                            Image(systemName: \"delete.left\")\n                                .resizable()\n                                .scaledToFit()\n                                .frame(width: 20, height: 20, alignment: .center)\n                                .foregroundStyle(Color.red)\n                        }\n                    }\n                    .padding(.horizontal, 20)\n                }\n            }\n\n            Spacer()\n\n            HStack {\n                if self.viewModel.itemsLeft > 0 {\n                    Text(\"\\(self.viewModel.itemsLeft) item(s) left\")\n                } else {\n                    Text(\"No items left\")\n                }\n\n                if self.viewModel.models.contains(where: { $0.completed }) {\n                    Button {\n                        Log.log(\"[UI] -> remove all completed task\", level: .info)\n                        removeAllCompleted()\n                    } label: {\n                        HStack {\n                            Image(systemName: \"trash\")\n                                .resizable()\n                                .scaledToFit()\n                                .frame(width: 20, height: 20, alignment: .center)\n                                .padding(.trailing, 10)\n                            Text(\"Clear all completed task!\")\n                        }\n                        .foregroundStyle(Color.red)\n                        .padding(5)\n                        .background(\n                            RoundedRectangle(cornerRadius: 12)\n                                .stroke(Color.red, lineWidth: 2)\n                        )\n                    }\n                }\n            }\n        }\n        .padding()\n        .alert(\"Add New Todo\", isPresented: self.$showAdding) {\n            TextField(\"What needs to be done?\", text: self.$newTaskName)\n            HStack {\n                Button {\n                    addTask()\n                    Log.log(\"[UI] -> Add new task: \\(self.newTaskName)\", level: .info)\n                    self.showAdding = false\n                } label: {\n                    Text(\"Confirm\")\n                }\n                .disabled(self.newTaskName.isEmpty)\n\n                Button {\n                    Log.log(\"[UI] -> Cancel Add new task: \\(self.newTaskName)\", level: .info)\n                    self.showAdding = false\n                } label: {\n                    Text(\"Cancel\")\n                }\n            }\n        } message: {\n            Text(\"Add new task to do here!\")\n        }\n        .alert(\"Edit task name\", isPresented: self.$showEditing) {\n            TextField(\"What needs to be done?\", text: self.$newTaskName)\n            HStack {\n                Button {\n                    Log.log(\"[UI] -> Update task: \\(self.newTaskName)\", level: .info)\n                    update()\n                    self.showEditing = false\n                } label: {\n                    Text(\"Close\")\n                }\n\n                Button {\n                    Log.log(\"[UI] -> Cancel update task: \\(self.newTaskName)\", level: .info)\n                    self.showEditing = false\n                } label: {\n                    Text(\"Cancel\")\n                }\n            }\n        } message: {\n            Text(\"Add new task to do here!\")\n        }\n        .navigationTitle(\"Todo\")\n        .onChange(of: self.viewModel.models) { newValue in\n            Log.log(\"[UI] [VM] -> models: \\(newValue)\", level: .info)\n            let hasChanged = newValue.contains(where: { $0.completed == false })\n            self.selectedAll = !hasChanged\n        }\n        .onChange(of: self.selectedAll) { newValue in\n            Log.log(\"[UI] [VM] -> selectedAll: \\(newValue)\", level: .info)\n            if newValue == false {\n                if self.viewModel.models.allSatisfy({ $0.completed == true }) {\n                    self.viewModel.markAllAsComplete(newValue)\n                }\n                return\n            }\n            self.viewModel.markAllAsComplete(newValue)\n        }\n    }\n\n    private func errorView(_ error: TDError) -> some View {\n        Text(\"Error occur: \\(error.localizedDescription)\")\n    }\n\n    private var loadingView: some View {\n        ProgressView()\n    }\n\n    var headerView: some View {\n        VStack {\n            HStack {\n                Spacer()\n                Text(self.viewModel.appVersion)\n            }\n            HStack {\n                Picker(\"\", selection: self.$selectedStatus) {\n                    ForEach(self.status) { pickerStatus in\n                        Text(\"\\(pickerStatus.rawValue)\")\n                            .tag(pickerStatus)\n                    }\n                }\n                // .pickerStyle(.palette)\n\n                Spacer()\n                Button {\n                    Log.log(\"[UI] -> Show add new task\", level: .info)\n                    self.showAdding = true\n                } label: {\n                    Image(systemName: \"plus\")\n                        .resizable()\n                        .scaledToFit()\n                        .padding(6)\n                        .frame(width: 30, height: 30)\n                        .padding(5)\n                        .background(Color.green.opacity(0.3))\n                        .cornerRadius(20)\n                }\n            }\n\n            if !self.viewModel.models.isEmpty {\n                Toggle(isOn: self.$selectedAll) {\n                    Text(\"Marked all as complete!\")\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Functions\n\nextension ContentView {\n    private func addTask() {\n        Log.log(\"[UI] -> addTask\", level: .info)\n        self.viewModel.addNewTask(self.newTaskName)\n        self.newTaskName = \"\"\n    }\n\n    private func update() {\n        Log.log(\"[UI] -> update task\", level: .info)\n        guard let model = updatingModel else { return }\n        self.viewModel.updateTask(model.id, self.newTaskName)\n\n        self.newTaskName = \"\"\n    }\n\n    private func complete(_ taskID: String, complete: Bool) {\n        Log.log(\"[UI] -> marks as compled task\", level: .info)\n        self.viewModel.updateTask(taskID, complete: complete)\n    }\n\n    private func removeAllCompleted() {\n        Log.log(\"[UI] -> remove all completed task\", level: .info)\n        self.viewModel.removeAllCompleted()\n    }\n}\n\n#Preview {\n    ContentView()\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"ContentViewModel.swift","path":"/TODO/ContentViewModel.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Combine\nimport Foundation\nimport Network\nimport Yorkie\n\nenum ContentState {\n    case loading\n    case error(TDError)\n    case success\n}\n\nextension ContentView {\n    class ContentViewModel: ObservableObject {\n        var appVersion: String {\n            var version = \"\"\n            if let appVersion = Bundle.main.object(forInfoDictionaryKey: \"CFBundleShortVersionString\") as? String {\n                version.append(appVersion)\n            } else {\n                print(\"Could not retrieve app version.\")\n            }\n\n            // Get the build number (CFBundleVersion)\n            if let buildNumber = Bundle.main.object(forInfoDictionaryKey: \"CFBundleVersion\") as? String {\n                version.append(\" build \")\n                version.append(buildNumber)\n            } else {\n                print(\"Could not retrieve build number.\")\n            }\n            return version\n        }\n\n        private let monitor = NWPathMonitor()\n        private let queue = DispatchQueue.global(qos: .background)\n\n        var documentKey = Constant.documentKey\n        private let jsonDecoder = JSONDecoder()\n        private(set) var models = [TodoModel]() {\n            didSet {\n                self.itemsLeft = self.models.count(where: { $0.completed == false })\n            }\n        }\n\n        @Published private(set) var itemsLeft = 0\n        @Published private(set) var state = ContentState.loading\n        private var client: Client\n        private var document: Document\n        @Published var networkConnected = false\n\n        init() {\n            self.client = Client(\n                \"https://yorkie-api-qa.navercorp.com\",\n                .init(apiKey: Constant.apiKey)\n            )\n            // use Local server\n            // self.client = .init(Constant.serverAddress)\n            self.document = Document(key: Constant.documentKey)\n\n            Log.log(\"Document key: \\(Constant.documentKey)\", level: .info)\n            Log.log(\"API key: \\(Constant.apiKey)\", level: .info)\n\n            self.monitor.pathUpdateHandler = { [weak self] path in\n                if path.status == .satisfied {\n                    DispatchQueue.main.async {\n                        self?.syncAfterReconnect()\n                    }\n                }\n            }\n            self.monitor.start(queue: self.queue)\n        }\n    }\n}\n\nextension ContentView.ContentViewModel {\n    func initializeClient() async {\n        Log.log(\"initializeClient\", level: .debug)\n        state = .loading\n        do {\n            try await client.activate()\n\n            let doc = try await client.attach(self.document)\n\n            try self.document.update { root, _ in\n                var text = root.todos as? JSONArray\n                if text == nil {\n                    root.todos = JSONArray()\n                    text = root.todos as? JSONArray\n                } else {}\n            }\n            self.updateDoc(doc)\n\n            state = .success\n\n            await self.watch()\n        } catch {\n            state = .error(.cannotInitClient(\"\\(error.localizedDescription)\"))\n            Log.log(\"initializeClient error :\\(error.localizedDescription)\", level: .error)\n        }\n    }\n\n    func watch() async {\n        self.document.subscribe { [weak self] event, document in\n            Log.log(\"receive event: \\(event.type)\", level: .debug)\n            if case .syncStatusChanged = event.type {\n                self?.updateDoc(document)\n            } else if case .localChange = event.type {\n                self?.updateDoc(document)\n            }\n        }\n    }\n\n    func updateKeys(_ key: String) {\n        // let key = Constant.yesterDaydocumentKey\n        guard self.documentKey != key else { return }\n        self.documentKey = key\n        Task {\n            try await self.client.detach(self.document)\n            self.document = Document(key: key)\n            await self.initializeClient()\n        }\n    }\n\n    func syncAfterReconnect() {\n        Task {\n            try await self.client.sync()\n\n            try? self.document.update { root, _ in\n                guard let lists = root.todos as? JSONArray else {\n                    Log.log(\"Can not cast todos to JSONArray\", level: .error)\n                    return\n                }\n                var _models = [TodoModel]()\n                for i in lists {\n                    guard let i = i as? JSONObject else { continue }\n                    let completed = i.get(key: \"completed\") as? Bool\n                    let id = i.get(key: \"id\") as? String\n                    let text = i.get(key: \"text\") as? String\n\n                    guard let completed, let id, let text else { return }\n                    let model = TodoModel(completed: completed, id: id, text: text)\n                    _models.append(model)\n                }\n                self.models = _models\n            }\n        }\n    }\n\n    func refreshDocument() {\n        self.updateDoc(self.document)\n    }\n\n    func updateDoc(_ document: Document) {\n        Log.log(\"update document\", level: .debug)\n        if let root = document.getRoot().todos as? JSONArray {\n            var _models = [TodoModel]()\n            let iterator = root.makeIterator()\n            while let i = iterator.next() as? JSONObject {\n                let completed = i.get(key: \"completed\") as? Bool\n                let id = i.get(key: \"id\") as? String\n                let text = i.get(key: \"text\") as? String\n\n                guard let completed, let id, let text else { return }\n                let model = TodoModel(completed: completed, id: id, text: text)\n                _models.append(model)\n            }\n            self.models = _models\n            Log.log(\"All models: \\(_models)\", level: .debug)\n        } else {\n            Log.log(\"No todos key found!\", level: .warning)\n        }\n    }\n\n    func markAllAsComplete(_ value: Bool) {\n        Log.log(\"markAllAsComplete: \\(value)\", level: .debug)\n        try? self.document.update { root, _ in\n            guard let lists = root.todos as? JSONArray else { return }\n            let iterator = lists.makeIterator()\n            while let next = iterator.next() as? JSONObject {\n                next.set(key: \"completed\", value: value)\n            }\n        }\n    }\n\n    func deleteItem(_ id: String) {\n        Log.log(\"deleteItem: \\(id)\", level: .debug)\n        try? self.document.update { root, _ in\n            guard let lists = root.todos as? JSONArray else {\n                Log.log(\"can not convert todos to JSONArray: \\(String(describing: root.todos))\", level: .error)\n                return\n            }\n            let iterator = lists.makeIterator()\n            while let next = iterator.next() as? JSONObject {\n                guard let data = String(reflecting: next).data(using: .utf8) else { return }\n                if let model = try? self.jsonDecoder.decode(TodoModel.self, from: data), model.id == id {\n                    lists.remove(byID: next.getID())\n                    Log.log(\"can not decode TodoModel to from data: \\(String(data: data, encoding: .utf8) ?? \"NIL\")\", level: .error)\n                } else {\n                    Log.log(\"can not decode TodoModel to from data: \\(String(data: data, encoding: .utf8) ?? \"NIL\")\", level: .error)\n                }\n            }\n        }\n    }\n\n    func addNewTask(_ name: String) {\n        Log.log(\"addNewTask: \\(name)\", level: .debug)\n        try? self.document.update { root, _ in\n            let lists = root.todos as? JSONArray\n            if lists == nil {\n                Log.log(\"Init new task when this is the initial\", level: .debug)\n                root.todos = JSONArray()\n            }\n            guard let lists = root.todos as? JSONArray else {\n                Log.log(\"Can not cast todos to JSONArray\", level: .error)\n                return\n            }\n            let model = TodoModel.makeTodo(with: name)\n\n            lists.append(model)\n        }\n    }\n\n    func updateTask(_ task: String, _ withNewName: String) {\n        Log.log(\"updateTask: \\(task) -> \\(withNewName)\", level: .debug)\n        try? self.document.update { root, _ in\n            guard let lists = root.todos as? JSONArray else {\n                Log.log(\"Can not cast todos to JSONArray\", level: .error)\n                return\n            }\n            let iterator = lists.makeIterator()\n            while let next = iterator.next() as? JSONObject {\n                if (next.get(key: \"id\") as? String) == task {\n                    next.set(key: \"text\", value: withNewName)\n\n                    Log.log(\"Found task id: \\(task) -> \\(withNewName)\", level: .debug)\n                    break\n                }\n            }\n        }\n    }\n\n    func updateTask(_ task: String, complete: Bool) {\n        Log.log(\"updateTask: \\(task) -> complete: \\(complete)\", level: .debug)\n        try? self.document.update { root, _ in\n            guard let lists = root.todos as? JSONArray else {\n                Log.log(\"Can not cast todos to JSONArray\", level: .error)\n                return\n            }\n            for i in lists {\n                if let object = i as? JSONObject, object.get(key: \"id\") as! String == task {\n                    object.set(key: \"completed\", value: complete)\n                    break\n                }\n            }\n        }\n    }\n\n    func removeAllCompleted() {\n        Log.log(\"removeAllCompleted\", level: .debug)\n        try? self.document.update { root, _ in\n            guard let lists = root.todos as? JSONArray else { return }\n            let iterator = lists.makeIterator()\n            while let next = iterator.next() as? JSONObject {\n                if (next.get(key: \"completed\") as? Bool) == true {\n                    lists.remove(byID: next.getID())\n                }\n            }\n        }\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"Log.swift","path":"/TODO/Log.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Foundation\nimport os\n\nenum LogLevel {\n    case debug, info, warning, notice, error, fault\n}\n\nstruct Log {\n    private static let `default` = Self(category: \"DEBUG\")\n    private let logger: Logger\n\n    private init(\n        subsystem: String = Bundle.main.bundleIdentifier ?? \"com.example.app.todo\",\n        category: String\n    ) {\n        self.logger = Logger(subsystem: subsystem, category: category)\n    }\n\n    static func log(_ message: String, level: LogLevel, _ function: String = #function, _ line: Int = #line, _ file: String = #fileID) {\n        switch level {\n        case .debug:\n            Self.default.debug(message, function, line, file)\n        case .info:\n            Self.default.info(message, function, line, file)\n        case .warning:\n            Self.default.warning(message, function, line, file)\n        case .notice:\n            Self.default.notice(message, function, line, file)\n        case .error:\n            Self.default.error(message, function, line, file)\n        case .fault:\n            Self.default.fault(message, function, line, file)\n        }\n    }\n}\n\nextension Log {\n    private func messageCentralize(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) -> String {\n        \"[LOG][\\(file):\\(function):\\(line)] -> \" + message\n    }\n\n    private func debug(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        self.logger.debug(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n    }\n\n    private func info(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        self.logger.info(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n    }\n\n    private func notice(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        self.logger.notice(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n    }\n\n    private func warning(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        self.logger.warning(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n    }\n\n    private func error(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        self.logger.error(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n    }\n\n    private func fault(_ message: String, _ function: String = #function, _ line: Int = #line, _ file: String = #file) {\n        self.logger.fault(\"\\(self.messageCentralize(message, function, line, file), privacy: .public)\")\n    }\n}\n"},{"isFile":true,"isOpen":false,"language":"swift","name":"TodomvcApp.swift","path":"/TODO/TodomvcApp.swift","content":"/*\n * Copyright 2025 The Yorkie Authors. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport SwiftUI\n\n@main\nstruct TodomvcApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate\n    @Environment(\\.scenePhase) var scenePhase\n\n    @State var key = Constant.documentKey\n\n    var body: some Scene {\n        WindowGroup {\n            NavigationView {\n                VStack {\n                    Text(\"Input document key or use the default\")\n                    TextField(text: self.$key) {\n                        Text(\"Input documentKey\")\n                    }\n\n                    NavigationLink(destination: ContentView()) {\n                        Text(\"Go\")\n                    }\n                }\n                .padding()\n            }\n            .navigationViewStyle(.stack)\n        }.onChange(of: self.scenePhase) { newPhase in\n            Log.log(\"[ChangePhase] -> \\(newPhase)\", level: .debug)\n        }\n        .onChange(of: self.key) { newValue in\n            Constant.documentKey = newValue\n        }\n    }\n}\n\nfinal class AppDelegate: NSObject, UIApplicationDelegate {\n    func application(\n        _: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil\n    ) -> Bool {\n        return true\n    }\n}\n"}]}]}