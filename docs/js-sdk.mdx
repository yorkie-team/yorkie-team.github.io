---
title: 'JS SDK'
order: 30
---

## JS SDK

Through Yorkie JS SDK, you can efficiently build collaborative applications. On the client-side implementation, you can create Documents that are automatically synced with remote peers with minimal effort.

If you want to install the SDK, refer to the [Getting Started with JS SDK](/docs/getting-started/with-js-sdk).

### Client

`Client` is a regular client that communicates with the server. It has documents and sends local changes to the server to synchronize with other replicas remotely.

#### Creating a Client

You can create a Client using `new yorkie.Client()`. After the Client has been activated, it is connected to the server and ready to use.

```javascript
const client = new yorkie.Client({
  rpcAddr: '{{API_ADDR}}',
  apiKey: 'xxxxxxxxxxxxxxxxxxxx',
});
await client.activate();
```

> The API key is used to identify the project in Yorkie. You can get the API key of the project you created in the [Dashboard]({{DASHBOARD_PATH}}).

#### Auth Token

You can configure authentication for the client by setting up an `authTokenInjector` to provide tokens for Auth Webhook verification.
If a `codes.Unauthenticated` error occurs, the `authTokenInjector` will be called again with the webhook's response reason, enabling automatic token refresh.
For more information about `Auth Webhook`, please refer to the [Auth Webhook](/docs/security#auth-webhook).

```javascript
const client = new yorkie.Client({
  rpcAddr: '{{API_ADDR}}',
  apiKey: 'xxxxxxxxxxxxxxxxxxxx',
  authTokenInjector: async (reason) => {
    // Handle token refresh logic based on webhook response
    if (reason === 'token expired') {
      return await refreshAccessToken();
    }
    return accessToken;
  },
});
```

#### Measuring MAU

You can measure MAU(Monthly Active Users) by setting the `userID` metadata when creating a client. The `userID` should be a unique identifier for each user.

```javascript
const client = new yorkie.Client({
  rpcAddr: '{{API_ADDR}}',
  apiKey: 'xxxxxxxxxxxxxxxxxxxx',
  metadata: { userID: 'user-1234' },
});
```

You can check the MAU in the [Dashboard]({{DASHBOARD_PATH}}) by selecting the project and clicking the `overview` tab.

#### Deactivate the Client

When the client is no longer needed, you can deactivate it to release resources and disconnect from the server.

```javascript
await client.deactivate();
```

This will detach all documents attached to the client for efficient [garbage collection](https://github.com/yorkie-team/yorkie/blob/main/design/garbage-collection.md).

### Document

`Document` is a primary data type in Yorkie that provides a JSON-like updating experience for representing your application's model. Documents can be updated without being attached to the client, and changes are automatically propagated to other clients when attached or when the network is restored.

#### Creating a Document

Create a Document with a unique key:

```javascript
const doc = new yorkie.Document('doc-1');
```

> Document keys can contain `a-z`, `A-Z`, `0-9`, `-`, `.`, `_`, `~` and must be less than 120 characters.

#### Attaching the Document

Attaching subscribes the client to a document. If the document doesn't exist on the server, it will be created. Once attached, all modifications are automatically synchronized with other clients.

Attach options:
- `initialPresence`: Sets the initial presence of the client that attaches the document. The presence is shared with other users participating in the document. It must be serializable to JSON.
- `syncMode`(Optional): Specifies synchronization modes. The default value is `SyncMode.Realtime`, which automatically pushes and pulls changes. If you set it to `SyncMode.Manual`, you'll need to manually handle synchronization.

```javascript
await client.attach(doc, {
  initialPresence: { color: 'blue', cursor: { x: 0, y: 0 } },
  syncMode: SyncMode.Manual,
});
```

#### Initializing root

Set initial values for the document root when attaching:

```javascript
await client.attach(doc, {
  initialRoot: {
    list: [1, 2, 3],
    counter: new yorkie.Counter(yorkie.IntType, 0),
  },
});
```

The initial values are partially applied. For each element in `initialRoot`:
- If the key doesn't exist, the element will be applied.
- If the key already exists in the Document, that element will be discarded. Users don't need to worry about overwriting existing valid counters.

```javascript
await client.attach(doc, {
  initialRoot: {
    list: [],
  },
});

// Another client tries to attach with initialRoot option:
await client.attach(doc, {
  initialRoot: {
    list: [1, 2, 3],    // this update will be discarded
    counter: new yorkie.Counter(yorkie.IntType, 0), // this update will be applied
  },
});

// final state
// root = {
//   list: [],
//   counter: {}
// }
```

We support element types for Primitives, and [Custom CRDT types](/docs/js-sdk/#custom-crdt-types).

<Alert status="warning">
Elements added by `initialRoot` are applied locally after push-pull during `attach`, not sent to the server immediately.
</Alert>

#### Editing the Document

Use `Document.update(changeFn, message)` to modify a Document. The optional `message` parameter adds a description to the change.

```javascript
const message = 'update document for test';
doc.update((root) => {
  root.todos = [];
  root.todos.push('todo-1');
  root.obj = {
    name: 'yorkie',
    age: 14,
  };
  root.counter = new yorkie.Counter(yorkie.IntType, 0);
  root.counter.increase(1);
}, message);
```

Under the hood, `root` in the `update` function creates a `change`, a set of operations, using a JavaScript proxy. Every element has its unique ID, created by the logical clock. This ID is used by Yorkie to track which object is which.

You can get the contents of the Document using `document.getRoot()`.

```javascript
const root = doc.getRoot();
console.log(root.todos);    // ["todo-1"]
console.log(root.obj);      // {"name":"yorkie","age":14}
console.log(root.obj.name); // "yorkie"
console.log(root.counter.getValue()); // 1
```

#### Plain JavaScript Objects

Convert Yorkie's JSONObject types to plain JavaScript objects using `toJS()`:

```javascript
const root = doc.getRoot();

// Converting the entire root to a plain object
const plainObject = root.toJS();
console.log(plainObject); // Plain JavaScript object

// Converting specific nested objects
const plainTodos = root.todos.toJS();
const plainObj = root.obj.toJS();
```

<Alert status="info">
The `toJS()` method creates a deep copy as a plain JavaScript object, removing all Yorkie-specific metadata and proxies.
</Alert>

#### Detaching the Document

Detach documents when no longer needed to improve garbage collection efficiency:

```javascript
await client.detach(doc);
```

The `Remove on Detach` project setting enforces server-side removal when the last client detaches from a document.

#### Presence

Presence tracks and shares user state (e.g., cursor positions, selections) in real-time.

**Updating presence**

Update the current user's presence using `Document.update()`. Properties are merged, and unspecified properties remain unchanged: 

```javascript
doc.update((root, presence) => {
  presence.set({ cursor: { x: 1, y: 1 } });
});

// final state
// presence = { color: 'blue', cursor: { x: 1, y: 1 } }
// we can see that the changes made were merged and the final state of the current user's presence is as we desire
```

<Alert status="warning">
Note, the properties provided will be replaced entirely and not merely updated.

For example:

```javascript
await client.attach(doc, {
  // let's say 'color' is a property of cursor
  initialPresence: {cursor: { x: 0, y: 0, color: 'red'}}, 
});

doc.update((root, presence) => {
  // we want to change the x y coordinates of our cursor
  presence.set({ cursor: { x: 1, y: 1 } }); 
});

// final state
// presence = { cursor: { x: 1, y: 1 } } 
// we can see that all properties inside cursor get replaced (i.e. we lose the property 'color')
```
</Alert>

**Getting presence**

**Document.getPresence(clientID)** returns the presence of a specific client:

```javascript
doc.getPresence(client.getID()); // { color: 'blue', cursor: { x: 1, y: 1 } }
```

**Document.getMyPresence()** returns the presence of the current client:

```javascript
doc.getMyPresence(); // { color: 'blue', cursor: { x: 1, y: 1 } }
```

**Document.getPresences()** returns all participating clients with their presence:

```javascript
const users = doc.getPresences();
for (const { clientID, presence } of users ) {
  // Do something
}
```

Example: [Profile Stack](/examples/profile-stack)

**Subscribing to presence changes**

**Document.subscribe('presence')** notifies when clients watch, unwatch, or modify their presence.

The `initialized` event occurs when connecting, losing connection, or reconnecting to a watch stream.

<Alert status="warning">
Subscribe before attaching the document to ensure you receive the initial `initialized` event.
</Alert>

```javascript
const unsubscribe = doc.subscribe('presence', (event) => {
  if (event.type === 'initialized') {
    // event.value: Array of users currently participating in the document
  }

  if (event.type === 'watched') {
    // event.value: A user has joined the document editing in online
  }

  if (event.type === 'unwatched') {
    // event.value: A user has left the document editing
  }

  if (event.type === 'presence-changed') {
    // event.value: A user has updated their presence
  }
});
```

Use `my-presence` and `others` topics to distinguish between your own events and those of others.

**Document.subscribe('my-presence')** subscribes to the current client's presence changes.

Possible event types: `initialized`, `presence-changed`.

```javascript
const unsubscribe = doc.subscribe('my-presence', (event) => {
  // Do something
});
```

**Document.subscribe('others')** subscribes to other clients' presence changes.

Possible event types: `watched`, `unwatched`, `presence-changed`.

```javascript
const unsubscribe = doc.subscribe('others', (event) => {
  if (event.type === 'watched') {
    addUser(event.value);
  }

  if (event.type === 'unwatched') {
    removeUser(event.value);
  }

  if (event.type === 'presence-changed') {
    updateUser(event.value);
  }
});
```

#### Synchronization Modes

Change the synchronization mode using `client.changeSyncMode(doc, syncMode)`.

Available modes:

- `SyncMode.Realtime`: Local changes are automatically pushed to the server, and remote changes are pulled from the server.

- `SyncMode.RealtimePushOnly`: Only local changes are pushed, and remote changes are not pulled.

- `SyncMode.RealtimeSyncOff`: Changes are not synchronized, but the watch stream remains active.

- `SyncMode.Manual`: Synchronization no longer occurs in real-time, and the watch stream is disconnected. Manual handling is required for synchronization.

```javascript
// Enable automatic synchronization of both local and remote changes.
await client.changeSyncMode(doc, SyncMode.Realtime);

// Only push local changes automatically.
await client.changeSyncMode(doc, SyncMode.RealtimePushOnly);

// Synchronization turned off, but the watch stream remains active.
await client.changeSyncMode(doc, SyncMode.RealtimeSyncOff);

// Synchronization turned off, and the watch stream is disconnected.
await client.changeSyncMode(doc, SyncMode.Manual);
await client.sync(doc); // Trigger synchronization manually using the sync function.
```

#### Subscribing to Changes

Subscribe to document events including changes, connection status, and synchronization status.

**Document.subscribe()**

Subscribe to document modification events. The `event.type` can be `local-change`, `remote-change`, or `snapshot`:

```javascript
const unsubscribe = doc.subscribe((event) => {
  if (event.type === 'snapshot') {
    // `snapshot` delivered when the entire document is updated from the server.
  } else if (event.type === 'local-change') {
    // `local-change` delivered when calling document.update from the current client.
  } else if (event.type === 'remote-change') {
    // `remote-change` delivered when the document is updated from other clients.
    const { message, operations } = event.value;
    
    // You can access the operations that have been applied to the document.
    for (const op of operations) {
      // e.g.) { type: 'increase', value: 1, path: '$.counter' }
      switch (op.type) {
        case 'increase':
          // ...
          break;
      }
    }
  }
});
```

When the `event.type` is `local-change` or `remote-change`, the `event.value` is a changeInfo, which has `{operations, message}` properties.
For more information about changeInfo for document events, please refer to the [ChangeInfo](https://yorkie.dev/yorkie-js-sdk/api-reference/interfaces/ChangeInfo.html).

<Alert status="warning">
The `event.rawChange` value for `local-change` and `remote-change` events, and the `event.value.snapshot` for `snapshot` event, are set only when [`enableDevtools`](/docs/devtools/#install-the-extension) option is configured as `true`.
</Alert>

The `snapshot` event occurs when fetching changes from the server exceeds `SnapshotThreshold`. The server sends a complete snapshot instead of individual changes. [Example code](https://github.com/yorkie-team/yorkie-js-sdk/blob/9c7accdfe337b9c9e7c7d0d3b3acc335951866ce/public/index.html#L346-L350) for handling snapshots in CodeMirror.

<Alert status="warning">
Clients that haven't synchronized for a long time may receive a `snapshot` event. Ensure your application handles these events to maintain synchronization.
</Alert>

**Document.subscribe('$.path')**

Subscribe to changes for a specific path (e.g., `$.todos`):

```javascript
// The event is triggered when the value of the path("$.todos") is changed.
const unsubscribe = doc.subscribe('$.todos', (event) => { 
  // You can access the updated value of the path.
  const target = doc.getValueByPath('$.todos');
});
```

**Document.subscribe('connection')**

Monitor the watch stream connection status. Possible values: `StreamConnectionStatus.Connected` and `StreamConnectionStatus.Disconnected`.

```javascript
const unsubscribe = doc.subscribe('connection', (event) => {
  if (event.value === StreamConnectionStatus.Connected) {
    // The watch stream is connected.
  } else if (event.value === StreamConnectionStatus.Disconnected) {
    // The watch stream is disconnected.
  }
});
```

For more information about `StreamConnectionStatus`, please refer to the [StreamConnectionStatus](https://yorkie.dev/yorkie-js-sdk/api-reference/enums/StreamConnectionStatus.html).

**Document.subscribe('sync')**

Track synchronization status in `SyncMode.Realtime`. Possible values: `DocSyncStatus.Synced` and `DocSyncStatus.SyncFailed`.

```javascript
const unsubscribe = doc.subscribe('sync', (event) => {
  if (event.value === DocSyncStatus.Synced) {
    // The document is synchronized with the server.
  } else if (event.value === DocSyncStatus.SyncFailed) {
    // The document failed to synchronize with the server.
  }
});
```

For more information about `DocSyncStatus`, please refer to the [DocSyncStatus](https://yorkie.dev/yorkie-js-sdk/api-reference/enums/DocSyncStatus.html).

**Document.subscribe('status')**

Subscribe to document status changes. Possible values: `DocStatus.Attached`, `DocStatus.Detached`, and `DocStatus.Removed`.

```javascript
const unsubscribe = doc.subscribe('status', (event) => {
  if (event.value.status === DocStatus.Attached) {
    // The document is attached to the client.
  } else if (event.value.status === DocStatus.Detached) {
    // The document is detached from the client.
  } else if (event.value.status === DocStatus.Removed) {
    // The document is removed and cannot be edited
  }
});
```

For more information about `DocStatus`, please refer to the [DocStatus](https://yorkie.dev/yorkie-js-sdk/api-reference/enums/DocStatus.html).

<Alert status="warning">
In web applications, detecting browser closure or navigation is difficult. Yorkie's `client-deactivate-threshold` automatically deactivates inactive clients, which will trigger a `DocumentStatus.Detached` event. See [Client Deactivate Threshold](/docs/cli#client-deactivate-threshold).
</Alert>

**Document.subscribe('auth-error')**

Subscribe to authentication errors during `PushPull` or `WatchDocuments` operations:

```javascript
const unsubscribe = doc.subscribe('auth-error', (event) => {
  console.log(event.value);
  // event.value contains:
  // - reason: string
  // - method: 'PushPull' | 'WatchDocuments'
});
```

This subscription allows you to monitor when token refreshes occur due to authentication errors.  
For more information about `Auth Webhook`, please refer to the [Auth Webhook](/docs/security#auth-webhook).

**Document.subscribe('all')**

Subscribe to all document events. Used for [Devtools extension](/docs/devtools).

```javascript
const unsubscribe = doc.subscribe('all', (transactionEvent) => {
  for (const docEvent of transactionEvent) {
    console.log(docEvent);
  }
});
```

#### Custom CRDT Types

Specialized data types for collaborative applications. Created in `document.update()` callbacks.

**Text**

Supports collaborative text editing with styling attributes:

```javascript
doc.update((root) => {
  root.text = new yorkie.Text();            // {"text":""}
  root.text.edit(0, 0, 'hello');            // {"text":"hello"}
  root.text.edit(0, 1, 'H');                // {"text":"Hello"}
  root.text.setStyle(0, 1, { bold: true }); // {"text":"<b>H</b>ello"}
});
```

**Selection using presence**

Share text selection using presence instead of storing it permanently. Convert `index` to `position` for `Yorkie.Text`:

```javascript
// Update selection through text editing
codemirror.on('beforeChange', (cm, change) => {
  doc.update((root, presence) => {
    const range = root.content.edit(from, to, content); // return updated index range
    presence.set({
      selection: root.content.indexRangeToPosRange(range), // update presence
    });
  });
});

// Update selection using mouse or keyboard
codemirror.on('beforeSelectionChange', (cm, change) => {
  const fromIdx = cm.indexFromPos(change.ranges[0].anchor);
  const toIdx = cm.indexFromPos(change.ranges[0].head);
  doc.update((root, presence) => {
    presence.set({
      selection: root.content.indexRangeToPosRange([fromIdx, toIdx]), // update presence
    });
  });
});
```

- When applying other user's selection changes:

```javascript
doc.subscribe('others', (event) => {
  if (event.type === 'presence-changed') {
    const { clientID, presence } = event.value;
    const range = doc.getRoot().content.posRangeToIndexRange(presence.selection);
    // Handle the updated selection in the editor
  }
});
```

Examples:
- [CodeMirror example](https://github.com/yorkie-team/yorkie-js-sdk/blob/main/examples/vanilla-codemirror6)
- [Quill example](https://github.com/yorkie-team/yorkie-js-sdk/blob/main/examples/vanilla-quill)

**Counter**

Supports integer operations with concurrent modifications:

```javascript
doc.update((root) => {
  root.counter = new yorkie.Counter(yorkie.IntType, 1); // {"counter":1}
  root.counter.increase(2);                             // {"counter":3}
  root.counter.increase(3);                             // {"counter":6}
  root.counter.increase(-4);                            // {"counter":2}
});
```

#### TypeScript Support

To use the Document more strictly, you can use [type variable](https://www.typescriptlang.org/docs/handbook/2/generics.html) in TypeScript when creating a Document.

```typescript
import yorkie, { JSONArray } from '@yorkie-js/sdk';
type DocType = {
  list: JSONArray<number>;
  text: yorkie.Text;
};
type PresenceType = {
  username: string;
  color: string;
};

const doc = new yorkie.Document<DocType, PresenceType>('key');
await client.attach(doc, {
  initialPresence: {
    username: 'alice',
    color: 'blue',
  },
});
doc.update((root, presence) => {
  root.list = [1, 2, 3];
  root.text = new yorkie.Text();
  presence.set({ color: 'red' });
});
```

#### Document Limits

Yorkie enforces the following limits for system stability and performance. Configure these in the Dashboard's Project Settings.

| Limit | Description | Default Behavior |
|-------|-------------|------------------|
| **Max Attachments** | Maximum clients that can attach to a document simultaneously | Failed attachments require manual retry |
| **Max Subscribers** | Maximum clients that can maintain subscription streams | SDK auto-retries (1/sec) when limit reached |
| **Max Document Size** | Maximum allowed document size on attachment | Local updates exceeding limit are rejected |

**Understanding Document Size**

A document's size includes both visible content and CRDT metadata for synchronization. The actual size may exceed what you see in the editor.

- **Local updates** that exceed the size limit are rejected and not pushed to the server
- **Remote updates** are always applied to ensure state convergence across clients

Tip: Monitor connection status using `Document.subscribe('connection')` to detect when limits are reached.

#### Document Revisions

Save snapshots of your document at specific points in time, browse history, and restore previous versions.

**Creating a Revision**

Create a revision using `client.createRevision()`:

```javascript
// Create a revision with a label
const revision = await client.createRevision(doc, 'v1.0');

// Create a revision with a label and description
const revision = await client.createRevision(
  doc,
  'Feature complete',
  'Added user authentication and profile management'
);
```

Parameters:
- `doc`: The document to create a revision for
- `label`: A short, descriptive label for the revision (required)
- `description` (Optional): A detailed description of what changed in this revision

<Alert status="info">
Revisions are stored on the server and can be accessed by any client with access to the document. They persist independently of the document's current state.
</Alert>

**Listing Revisions**

List all revisions using `client.listRevisions()`:

```javascript
// Get the first 50 revisions (newest first)
const revisions = await client.listRevisions(doc);

// Get revisions with pagination
const revisions = await client.listRevisions(doc, {
  pageSize: 20,
  offset: 0,
  isForward: false, // false = newest first, true = oldest first
});

// Display revision information
revisions.forEach(revision => {
  console.log(`ID: ${revision.id}`);
  console.log(`Label: ${revision.label}`);
  console.log(`Description: ${revision.description}`);
  console.log(`Created at: ${revision.createdAt}`);
  console.log(`Server Sequence: ${revision.serverSeq}`);
});
```

Available options:
- `pageSize` (Optional, default: 50): Number of revisions to retrieve per request
- `offset` (Optional, default: 0): Number of revisions to skip for pagination
- `isForward` (Optional, default: false): Sort order - `false` for newest first, `true` for oldest first

Each revision summary includes:
- `id`: Unique identifier for the revision
- `label`: The label provided when creating the revision
- `description`: Optional description of the revision
- `createdAt`: Timestamp when the revision was created
- `serverSeq`: Server sequence number at the time of revision creation

**Getting Revision Details**

Get detailed information using `client.getRevision()`:

```javascript
// Get a specific revision by ID
const revision = await client.getRevision(doc, revisionId);

// Access the revision's snapshot, YSON representation
const snapshot = revision.snapshot;
console.log('Revision data:', snapshot);
```

The returned revision object contains:
- All metadata from the revision summary
- `snapshot`: document state at the time of the revision, [YSON](/docs/web-api#yson) representation

<Alert status="info">
The snapshot contains the full document data as it existed when the revision was created. This data can be used for comparison, preview, or restoration purposes.
</Alert>

**Parsing YSON Snapshots**

Revision snapshots are in YSON (Yorkie JSON) format. Use the `YSON` parser to convert them to usable data structures:

```javascript
import { YSON } from '@yorkie-js/sdk';

// Get a revision with its snapshot
const revision = await client.getRevision(doc, revisionId);

if (revision.snapshot) {
  try {
    // Parse the YSON snapshot into Yorkie's internal data structure
    const root = YSON.parse(revision.snapshot);
    
    // Access the parsed data
    console.log(root.title);     // Access primitive values
    console.log(root.todos);     // Access arrays
    console.log(root.obj.name);  // Access nested objects
  } catch (error) {
    console.error('Failed to parse YSON:', error);
  }
}
```

**Parsing with TypeScript types:**

You can provide type information for better type safety when parsing YSON snapshots:

```typescript
import { YSON } from '@yorkie-js/sdk';

type DocType = {
  title: string;
  content: YSON.Text;
  todos: Array<string>;
};

const revision = await client.getRevision(doc, revisionId);

if (revision.snapshot) {
  const root = YSON.parse<DocType>(revision.snapshot);
  // root is now typed as DocType
  console.log(root.title);
}
```

**Converting Text to String:**

When working with Yorkie's `Text` type in snapshots, you can use `YSON.textToString()` to convert it to a plain string:

```javascript
import { YSON } from '@yorkie-js/sdk';

const revision = await client.getRevision(doc, revisionId);

if (revision.snapshot) {
  const root = YSON.parse<{ content: YSON.Text }>(revision.snapshot);
  
  // Convert Yorkie Text to plain string
  const plainText = YSON.textToString(root.content);
  console.log(plainText);
  
  // You can now use this string in your application
  // For example, display it in a text editor or compare with other versions
}
```

<Alert status="info">
The YSON parser is designed to handle Yorkie's internal data structures. If you're working with standard Document data, you may also consider using the `toJS()` method on the live document for a simpler conversion to plain JavaScript objects.
</Alert>

**Restoring a Revision**

Restore a document to a previous revision using `client.restoreRevision()`:

```javascript
// Restore to a specific revision
await client.restoreRevision(doc, revisionId);

// Sync to ensure the restored state is propagated
await client.sync();
```

<Alert status="warning">
Restoring replaces the entire document state and cannot be undone automatically. Consider creating a new revision before restoring to preserve the current state.
</Alert>

**Example workflow:**

```javascript
// Create a revision
const v1 = await client.createRevision(doc, 'v1.0', 'Initial version');

// List all revisions
const revisions = await client.listRevisions(doc);

// Get revision details with snapshot
const revision = await client.getRevision(doc, v1.id);

// Restore to a previous revision
await client.restoreRevision(doc, v1.id);
await client.sync();
```


#### History (Undo/Redo)

Built-in undo/redo for all document changes.

**Basic Usage**

```javascript
doc.update((root) => {
  root.text = new yorkie.Text();
  root.text.edit(0, 0, 'Hello');
});

// Undo the last change
doc.history.undo();
console.log(doc.getRoot().text.toString()); // ""

// Redo the undone change
doc.history.redo();
console.log(doc.getRoot().text.toString()); // "Hello"
```

**Checking Availability**

```javascript
doc.update((root) => {
  root.counter = new yorkie.Counter(yorkie.IntType, 0);
  root.counter.increase(5);
});

console.log(doc.history.canUndo()); // true
console.log(doc.history.canRedo()); // false

doc.history.undo();
console.log(doc.history.canUndo()); // false
console.log(doc.history.canRedo()); // true
```

**Redo Stack Behavior**

New changes after undo clear the redo stack:

```javascript
doc.update((root) => {
  root.value = 1;
});

doc.update((root) => {
  root.value = 2;
});

doc.history.undo();
console.log(doc.history.canRedo()); // true

// Making a new change clears the redo stack
doc.update((root) => {
  root.value = 3;
});
console.log(doc.history.canRedo()); // false
```

**Supported Operations**

History supports all CRDT types and operations including:
- **Text**: edit operations (setStyle support is under development)
- **Object**: property set, delete operations
- **Array**: push, insert, delete, move operations
- **Counter**: increase operations
- **Tree**: Undo/Redo support is under development

```javascript
doc.update((root) => {
  root.todos = [];
  root.todos.push('Task 1');
  root.todos.push('Task 2');
});

doc.history.undo(); // Undoes 'Task 2' push
console.log(doc.getRoot().todos.toJS()); // ['Task 1']

doc.history.redo(); // Redoes 'Task 2' push
console.log(doc.getRoot().todos.toJS()); // ['Task 1', 'Task 2']
```

**Limitations**

- **Maximum Stack Depth**: 50 changes per stack.
- **Not Available During Update**: You cannot call `undo()` or `redo()` inside a `doc.update()` callback.

```javascript
doc.update((root) => {
  doc.history.undo(); // ❌ Throws Error: "Undo is not allowed during an update"
});
```

- **Local Only**: History tracks only local changes. Remote changes are applied but not added to undo/redo stacks.

<Alert status="info">
Undo/redo operations only affect your own editing history and seamlessly integrate with changes from other users.
</Alert>

**Examples**

For complete working examples of history implementation, see:
- [Vanilla CodeMirror6 Example](https://github.com/yorkie-team/yorkie-js-sdk/tree/main/examples/vanilla-codemirror6) - Text editor with undo/redo
- [Whiteboard Example](https://github.com/yorkie-team/yorkie-js-sdk/blob/main/packages/sdk/public/whiteboard.html) - Visual example with history UI

### Channel

`Channel` is a communication channel that enables real-time pub/sub messaging and presence tracking between clients. Unlike Documents which persist and synchronize data, Channels are designed for ephemeral, real-time communication such as chat messages, notifications, and presence indicators.

#### Creating a Channel

You can create a Channel with a unique identifier and attach it to the Client:

```javascript
const channel = new yorkie.Channel('room-123');
await client.attach(channel);
```

> The channel key is used to identify the Channel in Yorkie. Clients with the same channel key can communicate with each other through pub/sub messaging.

#### Hierarchical Channel Keys

Channels support a hierarchical structure using periods (`.`) as separators, allowing you to organize channels into logical groups and subgroups. This is particularly useful for managing complex applications with multiple rooms, sections, or nested contexts.

```javascript
// Create channels with hierarchical keys
const roomChannel = new yorkie.Channel('room-1');
const sectionChannel = new yorkie.Channel('room-1.section-a');
const userChannel = new yorkie.Channel('room-1.section-a.user-123');

await client.attach(roomChannel);
await client.attach(sectionChannel);
await client.attach(userChannel);
```

Each level in the hierarchy maintains its own presence count and can be used independently. For example:
- `room-1` might track all users in a game room
- `room-1.section-a` might track users in a specific section of that room
- `room-1.section-a.user-123` might track presence for a specific user's context

**Channel Key Restrictions:**

When using hierarchical channel keys, follow these rules:

| Rule | Invalid Examples | Valid Examples |
|------|-----------------|----------------|
| Cannot start with a period | ❌ `.room-1`<br/>❌ `.room-1.section-1` | ✅ `room-1`<br/>✅ `room-1.section-1` |
| Cannot end with a period | ❌ `room-1.`<br/>❌ `room-1.section-1.` | ✅ `room-1`<br/>✅ `room-1.section-1` |
| Cannot contain consecutive periods | ❌ `room-1..section-1`<br/>❌ `room..section..subsection` | ✅ `room-1.section-1`<br/>✅ `room.section.subsection` |

**Distribute first-level channel keys:** Yorkie servers route channels based on the first-level key. Using the same first-level key (e.g., `app.*`) for all channels concentrates load on a single server, causing performance bottlenecks. Distribute traffic by using varied first-level keys:
  ```javascript
  // ✅ Good: Distributed first-level keys
  new yorkie.Channel('game-1.room-a');
  new yorkie.Channel('chat-1.thread-1');
  
  // ❌ Bad: Same first-level key
  new yorkie.Channel('app.game-1');
  new yorkie.Channel('app.chat-1');
  ```

**Query channel information:** Use the [GetChannels API](/docs/web-api#post-yorkiev1adminservicegetchannels) to retrieve presence counts for specific channels and their sub-levels.

#### Broadcast

Channels support a pub/sub pattern for broadcasting ephemeral messages to all connected clients:

```javascript
// Subscribe to messages on a specific topic
const unsubscribe = channel.subscribe('chat', (event) => {
  console.log(`[${event.topic}] ${event.payload.message}`);
  console.log(`From: ${event.publisher}`);
});

// Broadcast a message to all clients in the same channel
await channel.broadcast('chat', { message: 'Hello, world!' });
```

The event object contains:
- `topic`: The topic name you subscribed to
- `payload`: The message data (must be JSON serializable)
- `publisher`: The client ID of the message sender

You can subscribe to multiple topics on the same channel:

```javascript
// Subscribe to different topics
channel.subscribe('chat', (event) => {
  console.log('Chat message:', event.payload);
});

channel.subscribe('notification', (event) => {
  console.log('Notification:', event.payload);
});

// Broadcast to different topics
await channel.broadcast('chat', { message: 'Hello!' });
await channel.broadcast('notification', { type: 'user-joined', user: 'Alice' });
```

<Alert status="warning">
Broadcast messages are ephemeral and only delivered to clients currently connected to the channel. Messages are not persisted or stored, so clients that join later will not receive previous messages.
</Alert>

#### Tracking Online Presence

Channels automatically track the number of connected clients, making it easy to display "users online" counters:

```javascript
// Subscribe to presence changes
const unsubscribe = channel.subscribe('presence', (event) => {
  console.log(`Users online: ${event.count}`);
});

// Get the current presence count
const count = channel.getPresenceCount();
console.log(`Currently ${count} users online`);
```

The presence count is automatically updated when clients connect or disconnect from the channel.

#### Detaching a Channel

When you're done with a channel, detach it to clean up resources and stop receiving messages:

```javascript
await client.detach(channel);
```

#### Use Cases

Channels are ideal for:
- **Chat applications**: Real-time messaging without persistence
- **Live notifications**: Temporary alerts and updates
- **Presence indicators**: Showing who's online or in a room
- **Cursor sharing**: Broadcasting cursor positions in collaborative tools
- **Event broadcasting**: Sending signals or triggers between clients

For persistent data that needs to be synchronized and stored, use [Document](#document) instead.

### Logger Options

The Logger outputs events occurring within the SDK to the console for debugging purposes. To modify these options, you can use the `setLogLevel` function.

```typescript
import { setLogLevel, LogLevel } from '@yorkie-js/sdk';

setLogLevel(LogLevel.Error); // Display logs with Error or higher
```

The available log levels for `setLogLevel` are:

| LogLevel | Description                     |
|----------|---------------------------------|
| `LogLevel.Trivial`  | Most verbose level, displays all logs    |
| `LogLevel.Debug`    | Detailed information for debugging       |
| `LogLevel.Info`     | General information                      |
| `LogLevel.Warn`     | Warnings and potential issues            |
| `LogLevel.Error`    | Errors and unexpected behavior           |
| `LogLevel.Fatal`    | Critical errors, may lead to termination |

Adjust the log level for flexible control over log verbosity in your application.


### Reference

For details on how to use the JS SDK, please refer to [JS SDK Reference](https://yorkie.dev/yorkie-js-sdk/api-reference/).
